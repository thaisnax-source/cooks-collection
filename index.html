<!--
Notes for Production:
1.  Logo: The logo is now linked directly for Vercel deployment.
2.  Tailwind CSS: This file uses the Tailwind CDN. For production, consider processing your CSS.
3.  API Keys: This version uses input fields for API keys, with Airtable credentials pre-filled.
4.  Performance: This version is optimized with IndexedDB caching and progressive data loading.
-->
<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sports Card Inventory System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .nav-link.active {
            background-color: #4f46e5; /* indigo-600 */
            color: #ffffff;
        }
        .dark .nav-link.active {
            background-color: #6366f1; /* indigo-500 */
        }
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            color: white;
            z-index: 150;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            transform: translateY(-20px);
        }
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        .toast.success { background-color: #10B981; }
        .toast.error { background-color: #EF4444; }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: white;
            padding: 0; /* Remove padding for full control */
            border-radius: 0.5rem;
            max-width: 500px;
            width: 90%;
            transform: scale(0.95);
            transition: transform 0.3s;
        }
        .dark .modal-content { background: #1f2937; }
        .modal-overlay.show .modal-content {
            transform: scale(1);
        }
        .modal-content-body {
            padding: 2rem;
        }
        .modal-content-header {
            padding: 1rem 2rem;
            border-bottom: 1px solid #e5e7eb;
        }
        .dark .modal-content-header {
             border-bottom-color: #374151;
        }
        
        .comps-view .modal-content { max-width: 60rem; } 
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .skeleton {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            background-color: #e5e7eb;
        }
        .dark .skeleton { background-color: #374151; }
        @keyframes pulse { 50% { opacity: .5; } }
        .photo-dropzone { border: 2px dashed #d1d5db; }
        .dark .photo-dropzone { border-color: #4b5563; }
        .photo-dropzone.dragover { border-color: #4f46e5; background-color: #eef2ff; }
        .dark .photo-dropzone.dragover { background-color: #312e81; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300">
    <script>
        // Apply theme on initial load to prevent flash
        if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    </script>

    <!-- Main Container -->
    <div id="app" class="p-4 md:p-6">
        <!-- App shell will be rendered here by JavaScript -->
    </div>
    
    <input type="file" id="photo-upload-input" class="hidden" accept="image/*">

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>

    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-content-header">
                <h3 id="modal-title" class="text-lg font-bold">Are you sure?</h3>
            </div>
            <div class="modal-content-body">
                <div id="modal-body" class="mb-6">This action cannot be undone.</div>
                <div class="flex justify-end space-x-4">
                    <button id="modal-cancel-btn" class="bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 text-gray-800 dark:text-gray-200 font-bold py-2 px-4 rounded">Cancel</button>
                    <button id="modal-confirm-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">Confirm</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Run Comps Modal -->
    <div id="run-comps-modal" class="modal-overlay comps-view">
        <div class="modal-content max-w-4xl w-full max-h-[90vh] overflow-y-auto relative">
             <button id="comps-cancel-btn" class="absolute top-3 right-4 text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 text-3xl font-bold z-10">&times;</button>
            <div class="modal-content-header">
                <h3 id="comps-modal-title" class="text-xl font-bold">Running Comps...</h3>
            </div>
            <div class="modal-content-body">
                <div id="comps-progress" class="mt-4">
                    <!-- Progress steps will be injected here -->
                </div>
                <div id="comps-results" class="hidden">
                    <!-- Results will be injected here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Optimization: Add idb-keyval library for IndexedDB caching -->
    <script src="https://cdn.jsdelivr.net/npm/idb-keyval@6/dist/umd.js"></script>

    <script type="module">
        // --- CONFIG & STATE ---
        const THB_CONVERSION_RATE = 32;
        const CACHE_DURATION_MS = 60 * 60 * 1000; // 1 hour
        const LOCATIONS = [
            "Showcase", "Graded 1–9 Bin", "Graded 9.5–10 Premium Bin", "Graded Anime/TCG",
            "Storage Box 5", "Storage Box 4", "Storage Box 3", "Storage Box 2", "Storage Box 1",
            "HG Safe", "Home Gallery Cabinet 1", "Raw 100–300", "Raw 300–1K",
            "Raw Premium 1K+", "Raw Anime 300+", "Storage Box 6"
        ];
        const state = {
            records: [],
            currentView: 'dashboard',
            selectedCard: null,
            auditSelectedLocation: null,
            auditCurrentPage: 1,
            photoAuditType: null,
            searchQuery: '',
            searchField: 'Player',
            searchResults: [],
            searchCurrentPage: 1,
            _modalConfirmCallback: null,
            scanImageData: { front: null, back: null },
            photoUploadTarget: null,
            fromView: null, // Stores the previous view for back navigation
        };

        const getCredentials = () => ({
            apiKey: document.getElementById('apiKey').value,
            baseId: document.getElementById('baseId').value,
            tableName: document.getElementById('tableName').value,
            geminiApiKey: document.getElementById('geminiApiKey').value,
            imgbbApiKey: document.getElementById('imgbbApiKey').value,
        });
        
        // --- MAIN APP CONTAINER ---
        const appContainer = document.getElementById('app');

        // ====== PERFORMANCE OPTIMIZATION CORE START ======
        // Use IndexedDB for a fast, persistent, non-blocking cache.

        // ---- FIX: Use createStore for idb-keyval v6+ ----
        const customStore = idbKeyval.createStore('cooks-collection-cache', 'airtable');
        const CACHE_KEYS = {
            summary: 'records:summary',      // Lightweight fields for instant render
            full: 'records:full',            // Complete records for detailed views
            meta: 'records:meta',            // { lastFullSyncISO } for delta updates
        };

        // ---- Wrappers for IndexedDB cache operations using the custom store ----
        async function cacheGet(key){ return idbKeyval.get(key, customStore); }
        async function cacheSet(key, value){ return idbKeyval.set(key, value, customStore); }
        async function cacheDel(key){ return idbKeyval.del(key, customStore); }

        // ---- Helper to merge new records into an existing array by ID ----
        function mergeById(existingArr = [], incomingArr = []){
            const byId = new Map(existingArr.map(r => [r.id, r]));
            for (const r of incomingArr){ byId.set(r.id, { ...(byId.get(r.id)||{}), ...r }); }
            return Array.from(byId.values());
        }

        // --- API HELPERS & CACHING ---
        async function airtableFetch(method, path = '', body = null) {
            const { apiKey, baseId, tableName } = getCredentials();
            if (!apiKey || !baseId || !tableName) {
                const msg = "Airtable credentials are missing from the configuration.";
                showToast(msg, 'error');
                throw new Error(msg);
            }
            
            const url = `https://api.airtable.com/v0/${baseId}/${tableName}${path}`;
            const headers = { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' };
            const options = { method, headers };
            if (body) options.body = JSON.stringify(body);

            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    let errorText = `HTTP error! status: ${response.status}`;
                    try {
                        const errorData = await response.json();
                        console.error('Airtable Error details:', errorData); // Log full details
                        errorText = errorData.error?.message || errorText;
                    } catch {}
                    throw new Error(errorText);
                }
                return response.json();
            } catch (error) {
                console.error("Airtable API Error:", error);
                showToast(error.message, 'error');
                throw error;
            }
        }
        
        // ---- OPTIMIZED: Progressive Airtable fetch function ----
        // Fetches all records, supporting pagination, field selection, and filtering.
        async function fetchAllAirtableRecords(opts = {}){
            const { fields = null, filterByFormula = null, onBatch = null, pageSize = 100 } = opts;
            let all = [];
            let offset = null;
            const params = new URLSearchParams();
            params.set('view', 'Grid view');
            params.set('pageSize', String(pageSize));
            if (fields && Array.isArray(fields)) fields.forEach(f => params.append('fields[]', f));
            if (filterByFormula) params.set('filterByFormula', filterByFormula);

            do {
                const path = `?${params.toString()}${offset ? `&offset=${offset}` : ''}`;
                const data = await airtableFetch('GET', path);
                const batch = (data.records || []).map(r => ({ id: r.id, ...r.fields }));
                all = all.concat(batch);
                if (typeof onBatch === 'function') {
                    try { onBatch(batch); } catch {}
                }
                offset = data.offset;
            } while (offset);

            return all;
        }

        // ---- OPTIMIZED: Fetch only summary fields for a fast initial load ----
        async function fetchSummaryRecords(){
            const summaryFields = ['CardID', 'Player', 'Set', 'Current Sticker', 'Grading Company', 'Year', 'Location', 'FrontPhoto', 'BackPhoto'];
            return fetchAllAirtableRecords({ fields: summaryFields });
        }

        // ---- OPTIMIZED: Fetch only records updated since the last full sync ----
        async function backgroundDeltaRefresh(){
            const meta = (await cacheGet(CACHE_KEYS.meta)) || {};
            if (!meta.lastFullSyncISO) return null; // No baseline to compare against
            
            console.log(`[CACHE] Checking for updates since ${meta.lastFullSyncISO}`);
            const filter = `LAST_MODIFIED_TIME()>"${meta.lastFullSyncISO}"`;
            const updated = await fetchAllAirtableRecords({ filterByFormula: filter });
            
            if (updated.length === 0) {
                console.log('[CACHE] No new records found.');
                return null;
            }

            console.log(`[CACHE] Found ${updated.length} updated records. Merging into cache.`);
            // Merge into FULL and SUMMARY caches
            const full = (await cacheGet(CACHE_KEYS.full)) || [];
            const mergedFull = mergeById(full, updated);
            await cacheSet(CACHE_KEYS.full, mergedFull);

            const updatedSummary = updated.map(r => ({
                id: r.id, CardID: r.CardID, Player: r.Player, Set: r.Set, ['Current Sticker']: r['Current Sticker'], Location: r.Location, FrontPhoto: r.FrontPhoto, BackPhoto: r.BackPhoto
            }));
            const summary = (await cacheGet(CACHE_KEYS.summary)) || [];
            const mergedSummary = mergeById(summary, updatedSummary);
            await cacheSet(CACHE_KEYS.summary, mergedSummary);
             await cacheSet(CACHE_KEYS.meta, { lastFullSyncISO: new Date().toISOString() });

            return { updatedCount: updated.length, records: mergedFull };
        }
        
        // ====== PERFORMANCE OPTIMIZATION CORE END ======


        // --- UI UTILITIES ---
        function showLoader() {
            const contentArea = document.getElementById('content-area');
            if(contentArea) contentArea.innerHTML = '<div class="flex justify-center items-center h-64"><div class="loader"></div></div>';
        }
        
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            if(toast) {
                toast.textContent = message;
                toast.className = `toast ${type} show`;
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 4000);
            }
        }

        const formatCurrency = (value, currency = 'THB') => {
            const options = { style: 'currency', currency, minimumFractionDigits: 0, maximumFractionDigits: (currency === 'USD' ? 2 : 0) };
             if (currency === 'THB') {
                 return new Intl.NumberFormat('th-TH', options).format(value || 0);
            }
            return new Intl.NumberFormat('en-US', options).format(value || 0);
        };
        
        const formatTHBWithUSD = (thbValue) => {
            if (thbValue === undefined || thbValue === null) return '';
            const thbFormatted = formatCurrency(thbValue, 'THB');
            const usdValue = (thbValue || 0) / THB_CONVERSION_RATE;
            const usdFormatted = formatCurrency(usdValue, 'USD');
            return `${thbFormatted} (${usdFormatted})`;
        }

        function showConfirmationModal({ title, body, onConfirm }) {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-body').innerHTML = body;
            const modal = document.getElementById('confirmation-modal');
            modal.classList.add('show');
            state._modalConfirmCallback = onConfirm;
        }

        function hideConfirmationModal() {
            const modal = document.getElementById('confirmation-modal');
            modal.classList.remove('show');
            state._modalConfirmCallback = null;
        }
        
        function parseAndRenderCompNotes(notes) {
            if (!notes) return '';

            let links = [];
            let justification = '';

            const urlRegex = /(https?:\/\/[^\s]+)/g;

            const justificationIndex = notes.toLowerCase().indexOf('justification:');

            if (justificationIndex !== -1) {
                const linksAndHeaderSection = notes.substring(0, justificationIndex);
                links = linksAndHeaderSection.match(urlRegex) || [];
                
                justification = notes.substring(justificationIndex + 'justification:'.length).trim();
            } else {
                links = notes.match(urlRegex) || [];
                justification = notes;
            }

            if (justification.trim()) {
                const tempLinksString = (links.join(' ') + 'Links:').toLowerCase();
                let justTrimmed = justification.trim().toLowerCase();
                
                if (justTrimmed.startsWith(tempLinksString)) {
                    justification = justification.trim().substring(tempLinksString.length).trim();
                } else if (justTrimmed.startsWith('links:')) {
                    justification = justification.trim().substring(6).trim();
                }
            }
            
            if (links.length === 0 && !justification.trim()) {
                return `<div class="border rounded-md p-3 bg-gray-50 dark:bg-gray-800/50 whitespace-pre-wrap"><p class="text-sm">${notes}</p></div>`;
            }

            let html = '';
            if (links.length > 0) {
                html += `
                    <div>
                        <h5 class="font-semibold text-gray-600 dark:text-gray-400 mb-2">Comp Links</h5>
                        <div class="border rounded-md p-3 bg-gray-50 dark:bg-gray-800/50 max-h-40 overflow-y-auto">
                            <ul class="list-disc list-inside space-y-1.5">
                                ${links.map(link => `<li><a href="${link}" target="_blank" class="text-indigo-500 hover:underline break-all">${link}</a></li>`).join('')}
                            </ul>
                        </div>
                    </div>`;
            }

            if (justification.trim()) {
                const paragraphs = justification.trim().split('\n').filter(p => p.trim() !== '').map(p => `<p class="mb-2">${p}</p>`).join('');
                html += `
                    <div class="mt-4">
                        <h5 class="font-semibold text-gray-600 dark:text-gray-400 mb-2">Justification</h5>
                        <div class="border rounded-md p-3 bg-gray-50 dark:bg-gray-800/50 max-h-60 overflow-y-auto text-sm">
                            ${paragraphs}
                        </div>
                    </div>`;
            }
            return html;
        }


        // --- DASHBOARD MODULE ---
        // OPTIMIZED: This function now uses caching for instant loads.
        async function initDashboard() {
            const contentArea = document.getElementById('content-area');

            // 1) Try loading summary data from cache for an instant UI render.
            const cachedSummary = await cacheGet(CACHE_KEYS.summary);
            if (cachedSummary && Array.isArray(cachedSummary) && cachedSummary.length) {
                state.records = cachedSummary;
                renderDashboardFromState();
                console.log('[CACHE] Dashboard rendered instantly from summary cache.');

                // 1a) In the background, check for any records updated since the last sync.
                backgroundDeltaRefresh().then(update => {
                    if (update && state.currentView === 'dashboard') {
                        showToast(`${update.updatedCount} record(s) updated in the background.`);
                        state.records = update.records;
                        renderDashboardFromState();
                    }
                }).catch(e => console.error("Background delta refresh failed:", e));

                // 1b) Also in background, ensure the full record cache exists. If not, fetch it.
                const fullCache = await cacheGet(CACHE_KEYS.full);
                if (!fullCache || fullCache.length === 0) {
                    console.log('[CACHE] Full cache is empty. Hydrating in background...');
                    fetchAllAirtableRecords().then(async allRecords => {
                        await cacheSet(CACHE_KEYS.full, allRecords);
                        await cacheSet(CACHE_KEYS.meta, { lastFullSyncISO: new Date().toISOString() });
                        console.log('[CACHE] Full cache hydrated.');
                        if (state.currentView === 'dashboard') {
                            state.records = mergeById(state.records, allRecords);
                            renderDashboardFromState(); // Re-render with full data if anything changed
                        }
                    }).catch(e => console.error('Background full sync failed:', e));
                }
                return;
            }

            // 2) If no cache exists, show skeleton loader and perform the initial fetch.
            contentArea.innerHTML = `
                <div class="space-y-6">
                    <h2 class="text-xl font-bold">Dashboard</h2>
                    <div class="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
                        ${[...Array(4)].map(() => `<div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md skeleton h-24"></div>`).join('')}
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                         <div class="h-8 w-1/3 bg-gray-200 dark:bg-gray-700 rounded skeleton mb-4"></div>
                         <div class="space-y-2">
                            ${[...Array(5)].map(() => `<div class="h-12 w-full bg-gray-200 dark:bg-gray-700 rounded skeleton"></div>`).join('')}
                         </div>
                    </div>
                </div>`;

            try {
                // 2a) Fetch the lightweight summary first for a fast initial paint.
                console.log('[CACHE] No cache found. Fetching summary records...');
                const summary = await fetchSummaryRecords();
                state.records = summary;
                await cacheSet(CACHE_KEYS.summary, summary);
                renderDashboardFromState();
                console.log('[CACHE] Dashboard rendered with summary records.');

                // 2b) In the background, fetch the full dataset and populate the full cache.
                console.log('[CACHE] Fetching full records in background...');
                fetchAllAirtableRecords().then(async allRecords => {
                    await cacheSet(CACHE_KEYS.full, allRecords);
                    await cacheSet(CACHE_KEYS.meta, { lastFullSyncISO: new Date().toISOString() });
                    state.records = mergeById(summary, allRecords);
                    if (state.currentView === 'dashboard') renderDashboardFromState();
                    console.log('[CACHE] Full records cached in background.');
                }).catch(e => console.error('Background full sync failed:', e));
                
            } catch (error) {
                contentArea.innerHTML = `<p class="text-red-500">Failed to load dashboard data. ${error.message}</p>`;
            }
        }

        function renderDashboardFromState() {
            const records = state.records;
            let totalCards = records.length;
            let totalGraded = records.filter(r => r['Grading Company'] && r['Grading Company'] !== 'Raw').length;
            let totalRaw = totalCards - totalGraded;
            let totalStickerValue = records.reduce((sum, r) => sum + (r['Current Sticker'] || 0), 0);

            const latestRecords = records
                .sort((a, b) => (Number(b.CardID) || 0) - (Number(a.CardID) || 0))
                .slice(0, 10);

            renderDashboard({
                totalCards,
                totalGraded,
                totalRaw,
                totalStickerValue
            }, latestRecords);
        }
        
        function renderDashboard(summary, latest) {
            const contentArea = document.getElementById('content-area');
            contentArea.innerHTML = `
                <div class="space-y-6">
                    <h2 class="text-xl font-bold">Dashboard (${summary.totalCards} total cards)</h2>
                    <div class="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
                        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                            <h3 class="text-gray-500 dark:text-gray-400">Total Sticker Value</h3>
                            <p class="text-2xl font-bold">${formatCurrency(summary.totalStickerValue, 'THB')}</p>
                        </div>
                        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                            <h3 class="text-gray-500 dark:text-gray-400">Graded Cards</h3>
                            <p class="text-2xl font-bold">${summary.totalGraded}</p>
                        </div>
                        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                            <h3 class="text-gray-500 dark:text-gray-400">Raw Cards</h3>
                            <p class="text-2xl font-bold">${summary.totalRaw}</p>
                        </div>
                         <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                            <h3 class="text-gray-500 dark:text-gray-400">Graded vs Raw</h3>
                            <p class="text-2xl font-bold">${summary.totalCards > 0 ? ((summary.totalGraded / summary.totalCards) * 100).toFixed(1) : 0}% Graded</p>
                        </div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                        <h3 class="text-xl font-bold mb-4">Last 10 Entries</h3>
                        <div class="overflow-x-auto">
                            <table class="min-w-full">
                                <thead class="bg-gray-100 dark:bg-gray-700/50">
                                    <tr>
                                        <th class="px-6 py-4 text-left text-xs font-semibold uppercase tracking-wider">Year</th>
                                        <th class="px-6 py-4 text-left text-xs font-semibold uppercase tracking-wider">Player</th>
                                        <th class="px-6 py-4 text-left text-xs font-semibold uppercase tracking-wider">Set</th>
                                        <th class="px-6 py-4 text-left text-xs font-semibold uppercase tracking-wider">Card #</th>
                                        <th class="px-6 py-4 text-left text-xs font-semibold uppercase tracking-wider">Location</th>
                                        <th class="px-6 py-4 text-right text-xs font-semibold uppercase tracking-wider">Sticker</th>
                                    </tr>
                                </thead>
                                <tbody class="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                                    ${latest.map(item => `
                                        <tr class="hover:bg-gray-50 dark:hover:bg-gray-700/50">
                                            <td class="px-6 py-5 whitespace-nowrap">${item.Year || ''}</td>
                                            <td class="px-6 py-5 whitespace-nowrap">
                                                <a href="#" class="text-indigo-500 hover:underline view-card-link" data-record-id="${item.id}">${item.Player || ''}</a>
                                            </td>
                                            <td class="px-6 py-5 whitespace-nowrap">${item.Set || ''}</td>
                                            <td class="px-6 py-5 whitespace-nowrap">${item['Card#'] || ''}</td>
                                            <td class="px-6 py-5 whitespace-nowrap">${item.Location || ''}</td>
                                            <td class="px-6 py-5 whitespace-nowrap text-right">${formatCurrency(item['Current Sticker'], 'THB')}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
        }

        // --- INTAKE MODULE ---
        function initIntake(prefillData = null) {
            state.scanImageData = { front: null, back: null };
            if (prefillData && prefillData.record) {
                renderIntakeForm(prefillData.record, prefillData.isDuplicate);
            } else {
                renderIntakeChoice();
            }
        }

        function renderIntakeChoice() {
            const contentArea = document.getElementById('content-area');
            contentArea.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                    <h3 class="text-xl font-bold mb-4">How would you like to add a card?</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <button id="manual-entry-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-6 px-4 rounded-lg text-center transition-transform transform hover:scale-105">
                            <span class="text-3xl">✍️</span>
                            <p class="mt-2 font-semibold">Manual Entry</p>
                        </button>
                        <button id="scan-card-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-6 px-4 rounded-lg text-center transition-transform transform hover:scale-105">
                            <span class="text-3xl">📸</span>
                            <p class="mt-2 font-semibold">Scan Card with AI</p>
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('manual-entry-btn').addEventListener('click', () => renderIntakeForm());
            document.getElementById('scan-card-btn').addEventListener('click', renderScanCardView);
        }

        function renderScanCardView() {
            if (!getCredentials().geminiApiKey) {
                showToast('A Gemini API Key is required to scan cards.', 'error');
                return;
            }
            const contentArea = document.getElementById('content-area');
            contentArea.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                    <div class="flex justify-between items-start mb-4">
                        <div>
                            <h2 class="text-3xl font-bold tracking-tight">Scan Card with AI</h2>
                            <p class="text-lg text-gray-500 dark:text-gray-400">Upload front and back photos for analysis.</p>
                        </div>
                        <a href="#" class="text-blue-500 hover:underline flex-shrink-0 ml-4" data-view="intake">&larr; Back</a>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-start">
                        <!-- Front Scan -->
                        <div class="text-center">
                            <img id="scan-preview-front" class="w-full h-auto object-contain rounded-lg shadow-md mb-4 bg-gray-100 dark:bg-gray-700 aspect-[2.5/3.5]" src="https://placehold.co/400x560/eee/ccc?text=Front">
                            <input type="file" id="card-scan-front-input" class="hidden" accept="image/*" capture="environment">
                            <button data-side="front" class="card-scan-btn bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg w-full">Upload Front</button>
                        </div>
                        <!-- Back Scan -->
                        <div class="text-center">
                             <img id="scan-preview-back" class="w-full h-auto object-contain rounded-lg shadow-md mb-4 bg-gray-100 dark:bg-gray-700 aspect-[2.5/3.5]" src="https://placehold.co/400x560/eee/ccc?text=Back">
                            <input type="file" id="card-scan-back-input" class="hidden" accept="image/*" capture="environment">
                            <button data-side="back" class="card-scan-btn bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg w-full">Upload Back</button>
                        </div>
                    </div>
                    <div id="scan-loader-area" class="mt-6 text-center hidden">
                        <div class="loader mx-auto"></div>
                        <p id="scan-status" class="text-gray-500 mt-2">Analyzing card...</p>
                    </div>
                    <div class="mt-6 text-center">
                         <button id="analyze-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-8 rounded-lg w-full md:w-auto disabled:opacity-50 disabled:cursor-not-allowed" disabled>Analyze Photos</button>
                    </div>
                </div>
            `;
            document.querySelectorAll('.card-scan-btn').forEach(btn => 
                btn.addEventListener('click', () => document.getElementById(`card-scan-${btn.dataset.side}-input`).click())
            );
            document.getElementById('card-scan-front-input').addEventListener('change', (e) => handleCardScan(e, 'front'));
            document.getElementById('card-scan-back-input').addEventListener('change', (e) => handleCardScan(e, 'back'));
            document.getElementById('analyze-btn').addEventListener('click', analyzeCardImages);
        }

        function handleCardScan(e, side) {
            const file = e.target.files?.[0];
            if (!file) return;

            const previewImg = document.getElementById(`scan-preview-${side}`);
            if (!previewImg) {
                console.warn('Preview image not found for side:', side);
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (event) => {
                const dataUrl = event.target?.result;
                if (!dataUrl) return;

                previewImg.src = dataUrl;
                state.scanImageData[side] = {
                    base64: dataUrl.split(',')[1],
                    mimeType: file.type || 'image/jpeg'
                };
                document.getElementById('analyze-btn').disabled = !state.scanImageData.front;
            };
            reader.readAsDataURL(file);
        }
        
        async function analyzeCardImages() {
            document.getElementById('scan-loader-area').classList.remove('hidden');
            document.getElementById('analyze-btn').disabled = true;

            try {
                const extractedData = await getGeminiVisionData(state.scanImageData.front, state.scanImageData.back);
                document.getElementById('scan-status').textContent = 'Success! Populating form...';
                navigate('intake', { record: extractedData });
            } catch (error) {
                showToast(`AI analysis failed: ${error.message}`, 'error');
                document.getElementById('scan-status').textContent = `Analysis failed. Please try again.`;
                document.getElementById('analyze-btn').disabled = false;
                document.getElementById('scan-loader-area').classList.add('hidden');
            }
        }


        function renderIntakeForm(record = null, isDuplicate = false) {
            const isUpdate = record && record.id && !isDuplicate;
            const title = isUpdate ? `Editing Card: ${record.Player}` : 'Intake New Card';
            
            const nextCardID = isUpdate ? record.CardID : (Math.max(0, ...state.records.map(r => {
                const s = String(r.CardID ?? '');
                return /^\d+$/.test(s) ? Number(s) : 0;
            })) + 1).toString();
            
            const allLocations = [...new Set([...LOCATIONS, ...state.records.map(r => r.Location).filter(Boolean)])].sort();
            const locationOptions = allLocations.map(loc => `<option value="${loc}" ${record?.Location === loc ? 'selected' : ''}>${loc}</option>`).join('');

            const locationField = isUpdate ? `
                <div class="col-span-1 lg:col-span-2">
                    <label for="edit-location-select" class="block text-sm font-bold text-gray-700 dark:text-gray-300">Location</label>
                    <select id="edit-location-select" name="Location" class="mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 focus:ring-indigo-500 focus:border-indigo-500">
                        ${locationOptions}
                        <option value="__addNew__">Add New Location...</option>
                    </select>
                    <input id="edit-location-manual" type="text" class="mt-2 hidden w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800" placeholder="Enter new location name">
                </div>
            ` : '';

            const contentArea = document.getElementById('content-area');
            contentArea.innerHTML = `
                <form id="intake-form" data-record-id="${record?.id || ''}" data-mode="${isUpdate ? 'update' : 'create'}">
                    <div class="p-6 rounded-lg">
                        <div class="flex justify-between items-start mb-6">
                            <div>
                                <h2 class="text-3xl font-bold tracking-tight">${title}</h2>
                                <p class="text-lg text-gray-500 dark:text-gray-400">${isDuplicate ? `Adding a duplicate of ${record.Player}` : (record && record.id ? `${record.Year || ''} ${record.Set || ''}` : `Next Card ID: ${nextCardID}`)}</p>
                            </div>
                            <a href="#" class="text-indigo-500 hover:underline flex-shrink-0 ml-4" data-view="${isUpdate ? 'card-detail' : 'dashboard'}" data-record-id="${record?.id}">&larr; Cancel</a>
                        </div>

                        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                            <div class="md:col-span-1 space-y-6">
                               <div class="border dark:border-gray-700 rounded-xl shadow-sm overflow-hidden">
                                    <div class="bg-gray-50 dark:bg-gray-800/50 px-4 py-3 border-b dark:border-gray-700">
                                        <h4 class="font-bold">Photos</h4>
                                    </div>
                                    <div class="p-4 space-y-4">
                                        <div>
                                            <label class="block text-sm font-bold text-gray-700 dark:text-gray-300 mb-1">Front Photo</label>
                                            <input name="FrontPhoto" type="text" class="photo-url-input mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800" value="${record?.FrontPhoto?.[0]?.url || ''}" placeholder="Paste URL or Upload">
                                            <button type="button" data-field="FrontPhoto" class="upload-photo-btn mt-2 w-full bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 text-sm font-medium py-2 px-4 rounded">Upload Photo</button>
                                        </div>
                                        <div>
                                            <label class="block text-sm font-bold text-gray-700 dark:text-gray-300 mb-1">Back Photo</label>
                                            <input name="BackPhoto" type="text" class="photo-url-input mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800" value="${record?.BackPhoto?.[0]?.url || ''}" placeholder="Paste URL or Upload">
                                            <button type="button" data-field="BackPhoto" class="upload-photo-btn mt-2 w-full bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 text-sm font-medium py-2 px-4 rounded">Upload Photo</button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="md:col-span-2 space-y-6">
                               <div class="border dark:border-gray-700 rounded-xl shadow-sm overflow-hidden">
                                    <div class="bg-gray-50 dark:bg-gray-800/50 px-4 py-3 border-b dark:border-gray-700">
                                        <h4 class="font-bold">Card Details</h4>
                                    </div>
                                    <div class="p-4">
                                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                                            <div><label class="block text-sm font-bold text-gray-700 dark:text-gray-300">Player *</label><input name="Player" required class="mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 focus:ring-indigo-500 focus:border-indigo-500" value="${record?.Player || ''}"/></div>
                                            <div><label class="block text-sm font-bold text-gray-700 dark:text-gray-300">Set *</label><input name="Set" required class="mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 focus:ring-indigo-500 focus:border-indigo-500" value="${record?.Set || ''}"/></div>
                                            <div><label class="block text-sm font-bold text-gray-700 dark:text-gray-300">Year *</label><input name="Year" required class="mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 focus:ring-indigo-500 focus:border-indigo-500" value="${record?.Year || ''}"/></div>
                                            <div><label class="block text-sm font-bold text-gray-700 dark:text-gray-300">Card # *</label><input name="Card#" required class="mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 focus:ring-indigo-500 focus:border-indigo-500" value="${record?.['Card#'] || ''}"/></div>
                                            <div><label class="block text-sm font-bold text-gray-700 dark:text-gray-300">Subset</label><input name="Subset" class="mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 focus:ring-indigo-500 focus:border-indigo-500" value="${record?.Subset || ''}"/></div>
                                            <div><label class="block text-sm font-bold text-gray-700 dark:text-gray-300">Parallel</label><input name="Parallel" class="mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 focus:ring-indigo-500 focus:border-indigo-500" value="${record?.Parallel || ''}"/></div>
                                            <div><label class="block text-sm font-bold text-gray-700 dark:text-gray-300">Limited #</label><input name="Limited#" class="mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 focus:ring-indigo-500 focus:border-indigo-500" value="${record?.['Limited#'] || ''}"/></div>
                                        </div>
                                    </div>
                                </div>
                                <div class="border dark:border-gray-700 rounded-xl shadow-sm overflow-hidden">
                                    <div class="bg-gray-50 dark:bg-gray-800/50 px-4 py-3 border-b dark:border-gray-700">
                                        <h4 class="font-bold">Grading, Pricing & Location</h4>
                                    </div>
                                    <div class="p-4">
                                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                                            <div><label class="block text-sm font-bold text-gray-700 dark:text-gray-300">Grading Company</label><input name="Grading Company" class="mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 focus:ring-indigo-500 focus:border-indigo-500" value="${record?.['Grading Company'] || ''}"/></div>
                                            <div><label class="block text-sm font-bold text-gray-700 dark:text-gray-300">Grade</label><input name="Grade" class="mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 focus:ring-indigo-500 focus:border-indigo-500" value="${record?.Grade || ''}"/></div>
                                            <div><label class="block text-sm font-bold text-gray-700 dark:text-gray-300">Cert/Serial</label><input name="Cert/Serial" class="mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 focus:ring-indigo-500 focus:border-indigo-500" value="${record?.['Cert/Serial'] || ''}"/></div>
                                            <div><label class="block text-sm font-bold text-gray-700 dark:text-gray-300">Current Sticker (THB)</label><input name="Current Sticker" type="number" step="0.01" class="mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 focus:ring-indigo-500 focus:border-indigo-500" value="${record?.['Current Sticker'] || ''}"/></div>
                                            ${locationField}
                                        </div>
                                    </div>
                                </div>
                                <div class="pt-4">
                                    <button type="submit" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md" id="submit-btn">${isUpdate ? 'Save Changes' : 'Add Card'}</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </form>
            `;
            
            const locationSelect = document.getElementById('edit-location-select');
            if(locationSelect) {
                locationSelect.addEventListener('change', e => {
                    document.getElementById('edit-location-manual').classList.toggle('hidden', e.target.value !== '__addNew__');
                });
            }
            document.querySelectorAll('.upload-photo-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const { imgbbApiKey } = getCredentials();
                    if (!imgbbApiKey) {
                        showToast('Please enter an ImgBB API Key.', 'error');
                        return;
                    }
                    state.photoUploadTarget = btn.dataset.field;
                    document.getElementById('photo-upload-input').click();
                });
            });
            document.getElementById('intake-form').addEventListener('submit', handleIntakeSubmit);
        }
        
        async function handleIntakeSubmit(e) {
            e.preventDefault();
            const form = e.target;
            const submitBtn = document.getElementById('submit-btn');
            const mode = form.dataset.mode;
            const recordId = form.dataset.recordId;

            submitBtn.disabled = true;
            submitBtn.textContent = 'Submitting...';

            const formData = new FormData(form);
            const fields = {};
            for (let [key, value] of formData.entries()) {
                const trimmed = (value ?? '').toString().trim();
                
                if (key.includes('Photo')) {
                    if(trimmed) fields[key] = [{ url: trimmed }];
                    continue;
                }

                if (['Current Sticker', 'Original Sticker', 'Suggested Sticker', 'Max Dis'].includes(key)) {
                    fields[key] = trimmed === '' ? null : Number(trimmed);
                    continue;
                }
                
                fields[key] = trimmed === '' ? null : trimmed;
            }
            
            if (fields['Year'] !== null && fields['Year'] !== undefined && fields['Year'] !== '') {
              const y = Number(String(fields['Year']).replace(/[^\d]/g,''));
              if (Number.isFinite(y) && String(y).length >= 2) fields['Year'] = String(y);
            }

            function normalizeGrader(v) {
              const s = String(v || '').toUpperCase();
              if (!s) return null;
              if (s.includes('PSA')) return 'PSA';
              if (s.includes('BGS') || s.includes('BECKETT')) return 'BGS';
              if (s.includes('CGC')) return 'CGC';
              if (s.includes('SGC')) return 'SGC';
              if (s.includes('SQC')) return 'SQC';
              if (s.includes('RAW')) return 'Raw';
              return s;
            }
            fields['Grading Company'] = normalizeGrader(fields['Grading Company']);


            if(mode === 'create' && !fields['Grading Company']) {
                fields['Grade'] = 'NRMT';
            }

            if (mode === 'update') {
                const locationSelect = form.querySelector('#edit-location-select');
                if(locationSelect) {
                     fields.Location = locationSelect.value === '__addNew__'
                        ? form.querySelector('#edit-location-manual').value
                        : locationSelect.value;
                }
            }
            
            try {
                if (mode === 'create') {
                     const lastCardID = Math.max(
                        0,
                        ...state.records.map(r => {
                            const s = String(r.CardID ?? '');
                            return /^\d+$/.test(s) ? Number(s) : 0;
                        })
                    );
                    fields.CardID = String(lastCardID + 1);
                    fields.Location = 'INTAKE'; 

                    const newRecord = await airtableFetch('POST', '', { records: [{ fields }], typecast: true });
                    const newFullRecord = { id: newRecord.records[0].id, ...newRecord.records[0].fields };
                    state.records.push(newFullRecord);
                    await cacheSet(CACHE_KEYS.full, state.records);
                    
                    const summary = state.records.map(r => ({id: r.id, CardID: r.CardID, Player: r.Player, Set: r.Set, 'Current Sticker': r['Current Sticker'], Location: r.Location }));
                    await cacheSet(CACHE_KEYS.summary, summary);

                    showToast("Card added successfully!");
                    navigate('intake');
                } else {
                    await airtableFetch('PATCH', `/${recordId}`, { fields, typecast: true });
                    showToast("Card updated successfully!");
                    const recordIndex = state.records.findIndex(r => r.id === recordId);
                    if (recordIndex !== -1) {
                        const updatedRecord = { ...state.records[recordIndex], ...fields };
                        state.records[recordIndex] = updatedRecord;
                        state.selectedCard = updatedRecord;
                    }
                    await cacheSet(CACHE_KEYS.full, state.records);
                    const summary = state.records.map(r => ({id: r.id, CardID: r.CardID, Player: r.Player, Set: r.Set, 'Current Sticker': r['Current Sticker'], Location: r.Location }));
                    await cacheSet(CACHE_KEYS.summary, summary);
                    navigate('card-detail', { recordId });
                }
            } catch (error) {
                showToast(`Failed to ${mode === 'create' ? 'add' : 'update'} card.`, 'error');
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = mode === 'create' ? 'Add Card' : 'Save Changes';
            }
        }

        // --- AUDIT MODULE ---
        async function initAudit(location = null, page = 1) {
            showLoader();
            try {
                if (state.records.length === 0) {
                    const cachedRecords = await cacheGet(CACHE_KEYS.full) || await cacheGet(CACHE_KEYS.summary);
                    if(cachedRecords) {
                        state.records = cachedRecords;
                    } else {
                        state.records = await fetchAllAirtableRecords();
                        await cacheSet(CACHE_KEYS.full, state.records);
                        const summary = state.records.map(r => ({id: r.id, CardID: r.CardID, Player: r.Player, Set: r.Set, 'Current Sticker': r['Current Sticker'], Location: r.Location }));
                        await cacheSet(CACHE_KEYS.summary, summary);
                    }
                }
                
                state.auditSelectedLocation = location;
                state.auditCurrentPage = page;

                if (location) {
                    renderAuditLocationDetail();
                } else {
                    renderAuditSummary();
                }
            } catch (error) {
                 document.getElementById('content-area').innerHTML = `<p class="text-red-500">Failed to load audit data. Check credentials and console.</p>`;
            }
        }
        
        function renderAuditSummary() {
            const contentArea = document.getElementById('content-area');
            
            // Original Location Audit Logic
            const locationCounts = state.records.reduce((acc, record) => {
                const loc = record.Location || 'Uncategorized';
                acc[loc] = (acc[loc] || 0) + 1;
                return acc;
            }, {});
            const sortedLocations = Object.entries(locationCounts).sort((a, b) => a[0].localeCompare(b[0]));

            // New Photo Audit Logic
            const photoAuditCounts = state.records.reduce((acc, record) => {
                const loc = record.Location || 'Uncategorized';
                if (!acc[loc]) {
                    acc[loc] = { missingFront: 0, missingBack: 0, total: 0 };
                }
                acc[loc].total++;
                if (!record.FrontPhoto || record.FrontPhoto.length === 0) {
                    acc[loc].missingFront++;
                }
                if (!record.BackPhoto || record.BackPhoto.length === 0) {
                    acc[loc].missingBack++;
                }
                return acc;
            }, {});
            const sortedPhotoAudit = Object.entries(photoAuditCounts)
                .filter(([_, counts]) => counts.missingFront > 0 || counts.missingBack > 0)
                .sort((a, b) => a[0].localeCompare(b[0]));

            contentArea.innerHTML = `
                <div class="space-y-8">
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md space-y-4">
                        <h3 class="text-xl font-bold">Audit by Location</h3>
                        <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                            ${sortedLocations.map(([location, count]) => `
                                <a href="#" class="block p-4 bg-gray-50 dark:bg-gray-700 rounded-lg hover:bg-indigo-50 dark:hover:bg-indigo-900/50 transition-colors audit-location-link" data-location="${location}">
                                    <p class="font-semibold text-lg text-indigo-600 dark:text-indigo-400">${location}</p>
                                    <p class="text-gray-500 dark:text-gray-400">${count} card(s)</p>
                                </a>
                            `).join('')}
                        </div>
                    </div>

                    <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md space-y-4">
                        <h3 class="text-xl font-bold">Photo Audit</h3>
                        <div class="overflow-x-auto">
                            <table class="min-w-full">
                                <thead class="bg-gray-100 dark:bg-gray-700/50">
                                    <tr>
                                        <th class="px-6 py-4 text-left text-xs font-semibold uppercase tracking-wider">Location</th>
                                        <th class="px-6 py-4 text-center text-xs font-semibold uppercase tracking-wider">Missing Front Photos</th>
                                        <th class="px-6 py-4 text-center text-xs font-semibold uppercase tracking-wider">Missing Back Photos</th>
                                    </tr>
                                </thead>
                                <tbody class="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                                    ${sortedPhotoAudit.map(([location, counts]) => `
                                        <tr class="hover:bg-gray-50 dark:hover:bg-gray-700/50">
                                            <td class="px-6 py-4 whitespace-nowrap font-medium">${location}</td>
                                            <td class="px-6 py-4 whitespace-nowrap text-center">
                                                ${counts.missingFront > 0 ? `<a href="#" class="text-indigo-500 hover:underline photo-audit-link" data-location="${location}" data-photo-type="FrontPhoto">${counts.missingFront} missing</a>` : '<span>0</span>'}
                                            </td>
                                            <td class="px-6 py-4 whitespace-nowrap text-center">
                                                ${counts.missingBack > 0 ? `<a href="#" class="text-indigo-500 hover:underline photo-audit-link" data-location="${location}" data-photo-type="BackPhoto">${counts.missingBack} missing</a>` : '<span>0</span>'}
                                            </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderAuditLocationDetail() {
            const contentArea = document.getElementById('content-area');
            const location = state.auditSelectedLocation;
            const page = state.auditCurrentPage;
            const itemsPerPage = 10;

            const locationRecords = state.records
                .filter(r => (r.Location || 'Uncategorized') === location)
                .sort((a, b) => (Number(a.CardID) || 0) - (Number(b.CardID) || 0));

            const totalPages = Math.ceil(locationRecords.length / itemsPerPage);
            const startIndex = (page - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const paginatedRecords = locationRecords.slice(startIndex, endIndex);

            contentArea.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md space-y-4">
                    <div class="flex justify-between items-center">
                        <h3 class="text-xl font-bold">Location: ${location}</h3>
                        <a href="#" class="text-indigo-500 hover:underline" data-view="audit">&larr; Back to All Locations</a>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                           <thead class="bg-gray-100 dark:bg-gray-700/50">
                                <tr>
                                    <th class="px-4 py-3 text-left text-xs font-semibold uppercase tracking-wider">CardID</th>
                                    <th class="px-4 py-3 text-left text-xs font-semibold uppercase tracking-wider">Player</th>
                                    <th class="px-4 py-3 text-left text-xs font-semibold uppercase tracking-wider">Set</th>
                                    <th class="px-4 py-3 text-right text-xs font-semibold uppercase tracking-wider">Current Sticker</th>
                                </tr>
                            </thead>
                            <tbody class="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                                ${paginatedRecords.map(rec => `
                                    <tr class="hover:bg-gray-50 dark:hover:bg-gray-700/50">
                                        <td class="px-4 py-4">${rec.CardID}</td>
                                        <td class="px-4 py-4"><a href="#" class="text-indigo-500 hover:underline view-card-link" data-record-id="${rec.id}">${rec.Player || ''}</a></td>
                                        <td class="px-4 py-4">${rec.Set || ''}</td>
                                        <td class="px-4 py-4 text-right">${formatCurrency(rec['Current Sticker'])}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                    <div class="flex justify-between items-center mt-4">
                        <button class="pagination-btn bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 px-4 py-2 rounded" data-page-nav="prev" ${page === 1 ? 'disabled' : ''}>Previous</button>
                        <span>Page ${page} of ${totalPages}</span>
                        <button class="pagination-btn bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 px-4 py-2 rounded" data-page-nav="next" ${page === totalPages ? 'disabled' : ''}>Next</button>
                    </div>
                </div>
            `;
        }

        function renderAuditPhotoDetail(location, photoType) {
            state.auditSelectedLocation = location; // reuse this state property
            state.photoAuditType = photoType;
            const contentArea = document.getElementById('content-area');
            const page = state.auditCurrentPage;
            const itemsPerPage = 10;

            const locationRecords = state.records
                .filter(r => (r.Location || 'Uncategorized') === location)
                .filter(r => !r[photoType] || r[photoType].length === 0)
                .sort((a, b) => (Number(a.CardID) || 0) - (Number(b.CardID) || 0));

            const totalPages = Math.ceil(locationRecords.length / itemsPerPage);
            const startIndex = (page - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const paginatedRecords = locationRecords.slice(startIndex, endIndex);

            contentArea.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md space-y-4">
                    <div class="flex justify-between items-center">
                        <div>
                            <h3 class="text-xl font-bold">Photo Audit: ${location}</h3>
                            <p class="text-gray-500">Showing cards missing ${photoType === 'FrontPhoto' ? 'Front Photos' : 'Back Photos'}</p>
                        </div>
                        <a href="#" class="text-indigo-500 hover:underline" data-view="audit">&larr; Back to Audit Summary</a>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                           <thead class="bg-gray-100 dark:bg-gray-700/50">
                                <tr>
                                    <th class="px-4 py-3 text-left text-xs font-semibold uppercase tracking-wider">CardID</th>
                                    <th class="px-4 py-3 text-left text-xs font-semibold uppercase tracking-wider">Player</th>
                                    <th class="px-4 py-3 text-left text-xs font-semibold uppercase tracking-wider">Set</th>
                                </tr>
                            </thead>
                            <tbody class="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                                ${paginatedRecords.map(rec => `
                                    <tr class="hover:bg-gray-50 dark:hover:bg-gray-700/50">
                                        <td class="px-4 py-4">${rec.CardID}</td>
                                        <td class="px-4 py-4"><a href="#" class="text-indigo-500 hover:underline view-card-link" data-record-id="${rec.id}">${rec.Player || ''}</a></td>
                                        <td class="px-4 py-4">${rec.Set || ''}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                    <div class="flex justify-between items-center mt-4">
                        <button class="pagination-btn photo-audit-pagination bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 px-4 py-2 rounded" data-page-nav="prev" ${page === 1 ? 'disabled' : ''}>Previous</button>
                        <span>Page ${page} of ${totalPages || 1}</span>
                        <button class="pagination-btn photo-audit-pagination bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 px-4 py-2 rounded" data-page-nav="next" ${page >= totalPages ? 'disabled' : ''}>Next</button>
                    </div>
                </div>
            `;
        }
        
        // --- SEARCH MODULE ---
        async function initSearch(query = '', page = 1) {
            if (state.records.length === 0) {
                 const cachedRecords = await cacheGet(CACHE_KEYS.full) || await cacheGet(CACHE_KEYS.summary);
                if(cachedRecords) {
                    state.records = cachedRecords;
                } else {
                    showLoader();
                    state.records = await fetchAllAirtableRecords();
                    await cacheSet(CACHE_KEYS.full, state.records);
                    const summary = state.records.map(r => ({id: r.id, CardID: r.CardID, Player: r.Player, Set: r.Set, 'Current Sticker': r['Current Sticker'], Location: r.Location, FrontPhoto: r.FrontPhoto, BackPhoto: r.BackPhoto }));
                    await cacheSet(CACHE_KEYS.summary, summary);
                }
            }
            renderSearchView();
            const input = document.getElementById('search-query');
            const btn = document.getElementById('search-btn');
            
            input.value = query;
            state.searchQuery = query;
            
            function run() {
                state.searchQuery = input.value;
                const q = (state.searchQuery || '').trim().toLowerCase();
                if (!q) {
                    state.searchResults = [];
                    renderSearchResults(1);
                    return;
                };

                const FIELDS = ['CardID','Year','Set','Subset','Parallel','Player','Card#','Limited#','Grading Company','Grade','Cert/Serial','Location','User Notes','Comp Notes'];
                state.searchResults = state.records.filter(r => {
                    return FIELDS.some(field => String(r[field] || '').toLowerCase().includes(q));
                });

                renderSearchResults(1);
            }

            btn.addEventListener('click', run);
            input.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); run(); } });
            
            if(query) {
                run();
            }
        }

        function renderSearchView() {
            const contentArea = document.getElementById('content-area');
            contentArea.innerHTML = `
                <div class="space-y-4">
                    <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4">
                        <div class="grid md:grid-cols-[1fr_auto] gap-3 items-end">
                            <label class="block">
                                <span class="text-sm font-bold text-gray-700 dark:text-gray-300">Search cards (player, set, #, notes, etc.)</span>
                                <input id="search-query" class="w-full mt-1 rounded-md border-gray-300 dark:border-gray-600 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="e.g., 2023 Topps Chrome #211"/>
                            </label>
                            <button id="search-btn" class="rounded-md bg-indigo-600 text-white px-4 py-2 hover:bg-indigo-700">Search</button>
                        </div>
                    </div>
                    <div id="search-results"></div>
                </div>
            `;
        }

        function renderSearchResults(page = 1) {
            const out = document.getElementById('search-results');
            const records = state.searchResults;
            state.searchCurrentPage = page;
            const itemsPerPage = 10;
            
            const totalPages = Math.ceil(records.length / itemsPerPage);
            const startIndex = (page - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const paginatedRecords = records.slice(startIndex, endIndex);

            const rows = paginatedRecords.map(r => `
                <tr class="border-t dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700/50">
                    <td class="px-4 py-3">${r.CardID || ''}</td>
                    <td class="px-4 py-3"><a href="#" class="text-indigo-500 hover:underline view-card-link" data-record-id="${r.id}">${r.Player || ''}</a></td>
                    <td class="px-4 py-3">${r.Set || ''}</td>
                    <td class="px-4 py-3">${r.Location || ''}</td>
                    <td class="px-4 py-3 text-right">${formatCurrency(r['Current Sticker'])}</td>
                </tr>
            `).join('') || `<tr><td colspan="5" class="px-3 py-6 text-center text-gray-500 dark:text-gray-400">No matches found for "${state.searchQuery}"</td></tr>`;

            out.innerHTML = `
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md overflow-hidden">
                    <table class="min-w-full text-sm">
                        <thead class="bg-gray-100 dark:bg-gray-700/50">
                            <tr>
                                <th class="px-4 py-3 text-left font-semibold">CardID</th>
                                <th class="px-4 py-3 text-left font-semibold">Player</th>
                                <th class="px-4 py-3 text-left font-semibold">Set</th>
                                <th class="px-4 py-3 text-left font-semibold">Location</th>
                                <th class="px-4 py-3 text-right font-semibold">Sticker</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200 dark:divide-gray-700">
                            ${rows}
                        </tbody>
                    </table>
                </div>
                ${ records.length > itemsPerPage ? `
                <div class="flex justify-between items-center mt-4">
                    <button class="pagination-btn search-pagination-btn bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 px-4 py-2 rounded" data-page-nav="prev" ${page === 1 ? 'disabled' : ''}>Previous</button>
                    <span>Page ${page} of ${totalPages > 0 ? totalPages : 1}</span>
                    <button class="pagination-btn search-pagination-btn bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 px-4 py-2 rounded" data-page-nav="next" ${page >= totalPages ? 'disabled' : ''}>Next</button>
                </div>` : ''}
            `;
        }

        // --- CARD DETAIL MODULE ---
        async function updateCardLocation(recordId, newLocation) {
            if (!newLocation || !recordId) return;

            try {
                await airtableFetch('PATCH', `/${recordId}`, { fields: { 'Location': newLocation } });

                const recordIndex = state.records.findIndex(r => r.id === recordId);
                if (recordIndex !== -1) {
                    state.records[recordIndex].Location = newLocation;
                }
                if (state.selectedCard?.id === recordId) {
                    state.selectedCard.Location = newLocation;
                }
                await cacheSet(CACHE_KEYS.full, state.records);
                const summary = state.records.map(r => ({id: r.id, CardID: r.CardID, Player: r.Player, Set: r.Set, 'Current Sticker': r['Current Sticker'], Location: r.Location, FrontPhoto: r.FrontPhoto, BackPhoto: r.BackPhoto }));
                await cacheSet(CACHE_KEYS.summary, summary);


                showToast('Location updated!');
                renderCardDetail(); // Re-render to show static text and hide editor
            } catch (error) {
                showToast('Failed to update location.', 'error');
            }
        }

        async function initCardDetail(recordId) {
            showLoader();
             if (state.records.length === 0) {
                const cachedRecords = await cacheGet(CACHE_KEYS.full) || await cacheGet(CACHE_KEYS.summary);
                if(cachedRecords) {
                    state.records = cachedRecords;
                } else {
                    state.records = await fetchAllAirtableRecords();
                    await cacheSet(CACHE_KEYS.full, state.records);
                    const summary = state.records.map(r => ({id: r.id, CardID: r.CardID, Player: r.Player, Set: r.Set, 'Current Sticker': r['Current Sticker'], Location: r.Location, FrontPhoto: r.FrontPhoto, BackPhoto: r.BackPhoto }));
                    await cacheSet(CACHE_KEYS.summary, summary);
                }
            }
            
            const card = state.records.find(r => r.id === recordId);
            if(card) {
                state.selectedCard = card;
                renderCardDetail();
            } else {
                 document.getElementById('content-area').innerHTML = `<p class="text-red-500">Could not find card with ID ${recordId}. It may not be in the cache yet. Try refreshing.</p>`;
            }
        }

        function renderCardDetail() {
            const contentArea = document.getElementById('content-area');
            const card = state.selectedCard;
            if (!card) return;
            
            let backLinkHTML = `<a href="#" id="back-link" class="text-indigo-500 hover:underline flex-shrink-0 ml-4">&larr; Back</a>`;
            
            let contextualRecords = [];
            if (state.fromView?.view === 'audit' && state.fromView?.params?.location) {
                contextualRecords = state.records
                    .filter(r => r.Location === state.fromView.params.location)
                    .sort((a, b) => (Number(a.CardID) || 0) - (Number(b.CardID) || 0));
                backLinkHTML = `<a href="#" id="back-link" class="text-indigo-500 hover:underline flex-shrink-0 ml-4">&larr; Back to ${state.fromView.params.location}</a>`;

            } else if (state.fromView?.view === 'search') {
                contextualRecords = state.searchResults; // Already sorted/filtered
                 backLinkHTML = `<a href="#" id="back-link" class="text-indigo-500 hover:underline flex-shrink-0 ml-4">&larr; Back to Search</a>`;
            } else if (state.fromView?.view === 'audit-photo') {
                 contextualRecords = state.records
                    .filter(r => (r.Location || 'Uncategorized') === state.fromView.params.location)
                    .filter(r => !r[state.fromView.params.photoType] || r[state.fromView.params.photoType].length === 0)
                    .sort((a, b) => (Number(a.CardID) || 0) - (Number(b.CardID) || 0));
                 backLinkHTML = `<a href="#" id="back-link" class="text-indigo-500 hover:underline flex-shrink-0 ml-4">&larr; Back to Photo Audit</a>`;
            }


            let prevCardId = null;
            let nextCardId = null;
            let navigationHTML = '';

            if (contextualRecords.length > 0) {
                const currentIndex = contextualRecords.findIndex(r => r.id === card.id);
                if (currentIndex > -1) {
                    if (currentIndex > 0) {
                        prevCardId = contextualRecords[currentIndex - 1].id;
                    }
                    if (currentIndex < contextualRecords.length - 1) {
                        nextCardId = contextualRecords[currentIndex + 1].id;
                    }
                }
                 navigationHTML = `
                    <div class="flex justify-between mt-4">
                        <button data-action="navigate-prev" data-record-id="${prevCardId}" class="pagination-btn bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 px-4 py-2 rounded text-sm" ${!prevCardId ? 'disabled' : ''}>&larr; Previous Card</button>
                        <button data-action="navigate-next" data-record-id="${nextCardId}" class="pagination-btn bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 px-4 py-2 rounded text-sm" ${!nextCardId ? 'disabled' : ''}>Next Card &rarr;</button>
                    </div>
                `;
            }


            const currentSticker = card['Current Sticker'] || 0;
            const originalSticker = card['Original Sticker'] || 0;
            const delta = currentSticker - originalSticker;
            let deltaHTML = '';
            if (originalSticker > 0) {
                if (delta > 0) {
                    deltaHTML = `<p class="text-lg font-bold text-green-600 dark:text-green-400">↑ ${formatCurrency(delta, 'THB')}</p>`;
                } else if (delta < 0) {
                    deltaHTML = `<p class="text-lg font-bold text-red-600 dark:text-red-400">↓ ${formatCurrency(Math.abs(delta), 'THB')}</p>`;
                } else {
                    deltaHTML = `<p class="text-lg font-bold text-gray-500 dark:text-gray-400">• No Change</p>`;
                }
            } else if (currentSticker > 0) {
                 deltaHTML = `<p class="text-lg font-bold text-gray-500 dark:text-gray-400">First Sticker</p>`;
            } else {
                 deltaHTML = `<p class="text-lg font-bold text-gray-500 dark:text-gray-400">—</p>`;
            }
            
            const buildDetailRows = (rows) => {
                return rows.filter(row => row.value !== undefined && row.value !== null && row.value !== '')
                           .map((row, index) => `
                            <div class="flex justify-between py-3 px-4 ${index % 2 === 0 ? 'bg-slate-50 dark:bg-gray-800/50' : ''}">
                                <dt class="text-sm font-medium text-gray-500 dark:text-gray-400">${row.label}</dt>
                                <dd class="text-base text-right font-medium">${row.value}</dd>
                            </div>
                           `).join('');
            };

            const cardInfoRows = [
                { label: 'Year', value: card.Year },
                { label: 'Set', value: card.Set },
                { label: 'Card #', value: card['Card#'] },
                { label: 'Subset', value: card.Subset },
                { label: 'Parallel', value: card.Parallel },
                { label: 'Limited #', value: card['Limited#'] },
                { label: 'Card ID', value: card.CardID },
            ];
            
            const gradingInfoRows = [
                { label: 'Company', value: card['Grading Company'] },
                { label: 'Grade', value: card.Grade },
                { label: 'Cert/Serial', value: card['Cert/Serial'] },
            ];

            const cardInfoContent = buildDetailRows(cardInfoRows);
            const gradingInfoContent = buildDetailRows(gradingInfoRows);

            const renderDetailCard = (title, content) => {
                if (!content || !content.trim()) return '';
                return `
                    <div class="border dark:border-gray-700 rounded-xl shadow-sm overflow-hidden">
                        <div class="bg-gray-50 dark:bg-gray-800 px-4 py-3 border-b dark:border-gray-700">
                           <h4 class="font-bold">${title}</h4>
                        </div>
                        <div>${content}</div>
                    </div>
                `;
            };
            
            contentArea.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                    <div class="flex justify-between items-start mb-4">
                        <div>
                            <h2 class="text-3xl font-bold tracking-tight">${card.Player || 'Unknown Player'}</h2>
                            <p class="text-lg text-gray-500 dark:text-gray-400">${card.Year || ''} ${card.Set || ''}</p>
                        </div>
                         ${backLinkHTML}
                    </div>

                    ${navigationHTML}

                    <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mt-4">
                        <div class="md:col-span-1 space-y-4">
                            <div id="photo-display-container" class="space-y-2">
                                <img id="card-image-display" src="${card.FrontPhoto?.[0]?.url || 'https://placehold.co/400x560/eee/ccc?text=No+Front+Image'}" alt="Card Photo" class="rounded-lg w-full shadow-lg">
                                <div id="photo-controls" class="flex justify-center items-center space-x-4"></div>
                                <div class="mt-4 text-center p-3 bg-gray-50 dark:bg-gray-700/50 rounded-lg">
                                    <div id="location-display-view">
                                        <span class="text-sm font-medium text-gray-500 dark:text-gray-400">Location:</span>
                                        <span class="font-bold text-lg">${card.Location || 'N/A'}</span>
                                        <button data-action="edit-location-start" class="ml-2 text-indigo-500 hover:text-indigo-700 align-middle">
                                            <svg class="w-4 h-4 inline-block" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.5L13.196 5.232z"></path></svg>
                                        </button>
                                    </div>
                                    <div id="location-edit-view" class="hidden space-y-2">
                                        <select id="card-detail-location-select" class="w-full rounded-md border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"></select>
                                        <input id="card-detail-location-manual" type="text" class="hidden w-full rounded-md border-gray-300 dark:border-gray-600" placeholder="New location name">
                                        <div class="flex justify-center gap-2 mt-2">
                                            <button data-action="edit-location-cancel" class="text-xs bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 px-3 py-1 rounded">Cancel</button>
                                            <button data-action="edit-location-save" class="text-xs bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded">Save</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="md:col-span-2 space-y-6">
                            <div class="grid grid-cols-2 gap-4">
                                <div class="bg-indigo-50 dark:bg-indigo-900/50 border border-indigo-200 dark:border-indigo-800 rounded-lg p-4 text-center">
                                    <h4 class="text-sm font-medium text-indigo-800 dark:text-indigo-300">CURRENT STICKER</h4>
                                    <p class="text-4xl font-bold text-indigo-900 dark:text-indigo-200">${formatCurrency(card['Current Sticker'], 'THB')}</p>
                                </div>
                                 <div class="bg-gray-50 dark:bg-gray-700/50 rounded-lg p-4 text-center border dark:border-gray-700">
                                    <h4 class="text-sm font-medium text-gray-500 dark:text-gray-400">STICKER DELTA</h4>
                                    ${deltaHTML}
                                </div>
                                <div class="col-span-2 bg-gray-50 dark:bg-gray-700/50 rounded-lg p-4 text-center border dark:border-gray-700">
                                    <h4 class="text-sm font-medium text-gray-500 dark:text-gray-400">ORIGINAL STICKER</h4>
                                    <p class="text-xl font-bold">${formatCurrency(card['Original Sticker'], 'THB')}</p>
                                </div>
                            </div>

                            ${renderDetailCard('Card Details', cardInfoContent)}
                            ${renderDetailCard('Grading', gradingInfoContent)}
                            ${renderDetailCard('Comp Notes', parseAndRenderCompNotes(card['Comp Notes']))}

                            <div id="card-actions" class="flex flex-wrap items-center gap-4 pt-4 border-t dark:border-gray-700" data-record-id="${card.id}">
                                <button data-action="edit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Edit Card</button>
                                <button data-action="add-another" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">Add Another</button>
                                <button data-action="run-comps" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded">Run Comps</button>
                                <button data-action="delete" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded ml-auto">Delete Card</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // After rendering, populate photo controls
            const photoControls = document.getElementById('photo-controls');
            let controlsHTML = '';

            if (!card.FrontPhoto?.[0]?.url) {
                controlsHTML += `<div id="add-photo-FrontPhoto"><button data-action="add-photo-start" data-field="FrontPhoto" class="text-sm text-indigo-500 hover:underline">Add Front Photo</button></div>`;
            }

            if (card.BackPhoto?.[0]?.url) {
                controlsHTML += `<button data-action="toggle-photo" class="text-sm text-indigo-500 hover:underline">Show Back</button>`;
            } else {
                 controlsHTML += `<div id="add-photo-BackPhoto"><button data-action="add-photo-start" data-field="BackPhoto" class="text-sm text-indigo-500 hover:underline">Add Back Photo</button></div>`;
            }
            photoControls.innerHTML = controlsHTML;
        }
        
        // --- PRICING MODULE START ---
        
        /**
         * Builds a comprehensive list of search queries for a card.
         * @param {object} card - The card object from state.
         * @returns {{urls: string[]}}
         */
        function buildCardSearchQueries(card) {
            if (!card || typeof card !== 'object') {
                console.error("[COMPS] buildCardSearchQueries received invalid card object:", card);
                return { urls: [] };
            }
            
            const {
                Player, Year, Set: cardSet, Subset, Parallel,
                'Card#': CardNum, 'Grading Company': Grader, Grade,
                FrontPhoto, BackPhoto
            } = card;

            const character = Player || '';
            const setName = cardSet || '';

            let queryParts = [Year, setName, Subset, Parallel, character, CardNum ? `#${CardNum}` : ''].filter(Boolean).map(s => String(s).trim());
            
            // Extract keywords from photo filenames
            [FrontPhoto?.[0]?.url, BackPhoto?.[0]?.url].forEach(url => {
                if (!url) return;
                try {
                    const filename = new URL(url).pathname.split('/').pop();
                    const keywords = filename.replace(/[\.\_\-\d]/g, ' ').split(' ').filter(word => word.length > 2 && isNaN(word));
                    queryParts.push(...keywords);
                } catch (e) {
                    console.warn("Could not parse photo URL for keywords:", url);
                }
            });

            // Make query parts unique
            queryParts = [...new Set(queryParts)];
            const baseQuery = queryParts.join(' ');
            
            let gradedQuery = baseQuery;
            if (Grader && Grader !== 'Raw' && Grade) {
                gradedQuery += ` ${Grader} ${Grade}`;
            }

            const isTCG = /pokémon|one piece|yu-gi-oh|weiss schwarz|digimon|dragonball/i.test(setName);
            
            let urls = [];
            
            urls.push(`https://www.ebay.com/sch/i.html?_nkw=${encodeURIComponent(gradedQuery)}&LH_Complete=1&LH_Sold=1`);
            urls.push(`https://130point.com/sales/?search=${encodeURIComponent(gradedQuery)}`);
            
            if (isTCG) {
                urls.push(`https://www.tcgplayer.com/search/all/product?q=${encodeURIComponent(baseQuery)}`);
                urls.push(`https://www.cardmarket.com/en/OnePiece/Products/Singles?searchString=${encodeURIComponent(baseQuery)}`);
                urls.push(`https://tcgrepublic.com/category/category_page_1.html?search_word=${encodeURIComponent(baseQuery)}`);
                if (/pokémon/i.test(setName)) {
                    urls.push(`https://www.pokemonprice.com/Cards/Search/sales?q=${encodeURIComponent(baseQuery)}`);
                }
                urls.push(`https://auctions.yahoo.co.jp/search/search?p=${encodeURIComponent(baseQuery)}`);
            } else {
                // Add more sports-specific sources if needed
            }

            console.log('[COMPS] Generated Search URLs:', urls);
            return { urls: [...new Set(urls)] };
        }

        /**
         * Fetches comps and pricing analysis from the Gemini API.
         * @param {object} card - The card object.
         * @param {string|null} manualInstructions - Optional user-provided instructions.
         * @returns {Promise<object>} A structured object with pricing info.
         */
        async function getGeminiComps(card, manualInstructions = null) {
            const { geminiApiKey } = getCredentials();
            if (!geminiApiKey) {
                throw new Error("Gemini API key is not configured.");
            }

            console.log("[COMPS] Calling Gemini for card:", card);
            const { urls = [] } = buildCardSearchQueries(card) || {};

            const prompt = `
You are a master trading card dealer and pricing expert with a 'progressive learning mode,' meaning you learn from every query to improve your skills. Your task is to analyze the provided card details and research sources to determine a fair market value (FMV) and other pricing metrics.

**Card to Price:**
- Player/Character: ${card.Player || 'N/A'}
- Year: ${card.Year || 'N/A'}
- Set: ${card.Set || 'N/A'}
- Subset/Parallel: ${[card.Subset, card.Parallel].filter(Boolean).join(' / ') || 'N/A'}
- Card #: ${card['Card#'] || 'N/A'}
- Grading Co: ${card['Grading Company'] || 'Raw'}
- Grade: ${card.Grade || 'N/A'}
- Serial #: ${card['Limited#'] || 'N/A'}
- Cert #: ${card['Cert/Serial'] || 'N/A'}

**Research Sources (use these as a starting point):**
${urls.map(u => `- ${u}`).join('\n')}
${manualInstructions ? `\n**Manual Guidance (PRIORITIZE THIS):**\n${manualInstructions}\n` : ''}

**Instructions & Logic:**

1.  **Detect Category**: First, determine if the card is 'sports' or 'anime_tcg'.
2.  **Analyze Data**: Synthesize information from recent sold listings from the provided URLs.
    - **For TCG/Anime**: Prioritize TCG Republic, CardMarket, and Yahoo Japan Auctions. Use eBay for cross-validation. Normalize JPY and EUR to USD. Account for language variants (English vs. Japanese).
    - **For Sports**: Prioritize eBay and 130Point. Consider population reports if Cert # is available (low pop = higher value).
3.  **Pricing Logic & Adjustments**:
    - Calculate **FMV (Fair Market Value)** as the average of recent, relevant sold listings.
    - **Rookie Card (Sports)**: Apply a +15% premium to FMV.
    - **Numbered Cards (Sports)**: Adjust value proportionally (e.g., a /25 card is worth ~2x a /99 card of the same player/set).
    - **Raw Condition**: If 'Raw', discount value by 20-25% compared to a graded 8 equivalent.
    - **High Grade**: If Grade >= 9.5, apply a +10-15% premium over a Grade 9.
    - **TCG Rarity**: Identify rarity (Secret Rare, Alt Art, SR, etc.) and price within that tier's bracket for the set. If no direct sales, use comps from the same rarity tier.
4.  **Confidence Score**: Generate a confidence score (0-100) based on the number of comps, recency, and source diversity.
5.  **Reasoning**: Provide a detailed reasoning summary, including a "Category Insight" block with market context.
6.  **No Data**: If no comps or reasonable comparables exist, YOU MUST return \`"status": "NO_DATA"\`.

**JSON Output Structure (Strictly Adhere):**
\`\`\`json
{
  "status": "SUCCESS" | "NO_DATA" | "ERROR",
  "category": "sports" | "anime_tcg",
  "confidence": <number (0-100)>,
  "pricing": {
    "fmv_usd": <number | null>
  },
  "research": {
    "source_urls": ["<url1>", "<url2>", ...],
    "reasoning": "<string: Detailed summary>",
    "category_insight": "<string: Market context>"
  }
}
\`\`\`
`;
            try {
                const model = 'gemini-2.5-flash-preview-05-20';
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${geminiApiKey}`;
                const payload = { contents: [{ parts: [{ text: prompt }] }] };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Gemini API error (${response.status}): ${errorData.error?.message || 'Unknown error'}`);
                }

                const result = await response.json();
                const textResponse = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!textResponse) {
                    throw new Error("Empty response from Gemini.");
                }

                const jsonMatch = textResponse.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    console.error("[COMPS] Gemini raw response (no JSON found):", textResponse);
                    throw new Error("Could not parse JSON from Gemini response.");
                }

                const parsedJson = JSON.parse(jsonMatch[0]);
                console.log("[COMPS] Gemini Parsed JSON:", parsedJson);
                return parsedJson;

            } catch (error) {
                console.error("[COMPS] Full Gemini Error:", error);
                return {
                    status: "ERROR",
                    research: { reasoning: `An error occurred while contacting the pricing API: ${error.message}` }
                };
            }
        }

        /**
         * Main function to orchestrate the comps process.
         * @param {object} card - The card object.
         * @param {string|null} manualInstructions - Optional user-provided instructions.
         */
        async function executeRunComps(card, manualInstructions = null) {
            const modal = document.getElementById('run-comps-modal');
            const progressDiv = document.getElementById('comps-progress');
            const resultsDiv = document.getElementById('comps-results');
            const modalTitle = document.getElementById('comps-modal-title');
            
            modalTitle.textContent = `Running Comps for ${card.Player}...`;
            resultsDiv.classList.add('hidden');
            progressDiv.classList.remove('hidden');
            modal.classList.add('show');

            const steps = [
                "Connecting to eBay & TCG Databases...",
                "Connecting to SportscardMarket / 130Point...",
                "Connecting to PSA / BGS / CGC databases...",
                "Analyzing results and calculating fair value..."
            ];
            
            progressDiv.innerHTML = `<div class="flex justify-center"><div class="loader"></div></div>`;
            const statusContainer = document.createElement('div');
            statusContainer.className = 'mt-4 text-center space-y-1';
            progressDiv.appendChild(statusContainer);
            
            let stepIndex = 0;
            const interval = setInterval(() => {
                if (stepIndex < steps.length) {
                    const p = document.createElement('p');
                    p.className = 'text-gray-500 dark:text-gray-400';
                    p.textContent = steps[stepIndex];
                    statusContainer.appendChild(p);
                    stepIndex++;
                } else {
                    clearInterval(interval);
                }
            }, 1200);

            try {
                const compData = await getGeminiComps(card, manualInstructions);
                clearInterval(interval);
                
                if (compData.status === "SUCCESS" && compData.pricing?.fmv_usd) {
                    displayCompsResults(card, compData);
                } else if (compData.status === "NO_DATA") {
                    displayNoCompsFound(card);
                } else {
                    throw new Error(compData.research?.reasoning || "Failed to get a valid pricing structure.");
                }

            } catch (error) {
                clearInterval(interval);
                console.error("[COMPS] executeRunComps failed:", error);
                displayCompsError(error.message);
            }
        }

        /**
         * Displays the results in the modal if comps are found.
         * @param {object} card - The card object.
         * @param {object} compData - The structured data from Gemini.
         */
        function displayCompsResults(card, compData) {
            const { pricing, research, confidence, category } = compData;
            const resultsDiv = document.getElementById('comps-results');
            const progressDiv = document.getElementById('comps-progress');
            document.getElementById('comps-modal-title').textContent = 'Comps Analysis Complete!';
            
            const fmvUSD = pricing.fmv_usd || 0;
            const fmvTHB = fmvUSD * THB_CONVERSION_RATE;
            const groundFloorTHB = fmvTHB * 0.8;
            const ceilingTHB = fmvTHB * 1.2;
            const suggestedStickerTHB = Math.round((ceilingTHB * 0.95) / 50) * 50;
            
            const linksHTML = research.source_urls && research.source_urls.length > 0 
                ? research.source_urls.slice(0, 4).map(url => `<li><a href="${url}" target="_blank" class="text-indigo-500 hover:underline block truncate">${url}</a></li>`).join('')
                : '<p class="text-sm text-gray-500">No direct research links provided.</p>';
            
            resultsDiv.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Left Side: Pricing -->
                    <div class="space-y-4">
                        <div class="bg-green-50 dark:bg-green-900/50 border border-green-500 rounded-lg p-4 text-center">
                            <p class="font-semibold text-green-800 dark:text-green-300">Suggested Sticker Price</p>
                            <p class="text-4xl font-bold text-green-600 dark:text-green-400">${formatCurrency(suggestedStickerTHB)}</p>
                        </div>
                        <div class="grid grid-cols-2 gap-4 text-center">
                            <div class="bg-gray-100 dark:bg-gray-800 p-3 rounded-lg">
                                <p class="text-sm font-medium text-gray-500 dark:text-gray-400">Ground Floor</p>
                                <p class="font-bold text-lg">${formatCurrency(groundFloorTHB)}</p>
                            </div>
                            <div class="bg-gray-100 dark:bg-gray-800 p-3 rounded-lg">
                                <p class="text-sm font-medium text-gray-500 dark:text-gray-400">Ceiling</p>
                                <p class="font-bold text-lg">${formatCurrency(ceilingTHB)}</p>
                            </div>
                        </div>
                        <div class="bg-gray-100 dark:bg-gray-800 p-3 rounded-lg text-center">
                             <p class="text-sm font-medium text-gray-500 dark:text-gray-400">Fair Market Value (FMV)</p>
                             <p class="font-bold text-lg">${formatCurrency(fmvUSD, 'USD')} (≈ ${formatCurrency(fmvTHB)})</p>
                        </div>
                        <div class="bg-blue-50 dark:bg-blue-900/50 p-3 rounded-lg text-center">
                            <p class="text-sm font-medium text-blue-500 dark:text-blue-400">Confidence Score</p>
                            <p class="font-bold text-lg text-blue-700 dark:text-blue-300">${confidence}%</p>
                        </div>
                    </div>

                    <!-- Right Side: Research -->
                    <div class="space-y-4">
                        <div>
                            <h5 class="font-semibold text-gray-700 dark:text-gray-300 mb-1">Research Links</h5>
                            <ul class="list-disc list-inside space-y-1 bg-gray-50 dark:bg-gray-800/50 p-3 rounded-md border dark:border-gray-700">
                                ${linksHTML}
                            </ul>
                        </div>
                        <div>
                            <h5 class="font-semibold text-gray-700 dark:text-gray-300 mb-1">Reasoning</h5>
                            <div class="bg-gray-50 dark:bg-gray-800/50 p-3 rounded-md border dark:border-gray-700 text-sm space-y-2">
                                <p>${research.reasoning || 'No reasoning provided.'}</p>
                                ${research.category_insight ? `<p class="italic border-t dark:border-gray-600 pt-2 mt-2"><strong>Category Insight:</strong> ${research.category_insight}</p>` : ''}
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="mt-6 border-t dark:border-gray-700 pt-4">
                    <h4 class="font-bold text-lg">Refine or Save</h4>
                     <textarea id="manual-recomp-instructions" class="w-full rounded-md p-2 mt-2 border-gray-300 dark:border-gray-600" placeholder="Disagree? Provide new instructions... e.g., 'Those are base cards, this is a refractor.'"></textarea>
                    <div class="flex justify-between items-center mt-2">
                        <button id="manual-recomp-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded">Re-Comp with Instructions</button>
                        <div class="flex items-center gap-4">
                             <input id="final-sticker-price" type="number" step="10" class="block w-48 rounded-md p-2 border-gray-300 dark:border-gray-600" value="${suggestedStickerTHB || 0}">
                             <select id="final-location-select" class="block w-48 rounded-md p-2 border-gray-300 dark:border-gray-600"></select>
                             <button id="comps-accept-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded">Save</button>
                        </div>
                    </div>
                </div>
            `;
            
            const allLocations = [...new Set([...LOCATIONS, ...state.records.map(r => r.Location).filter(Boolean)])].sort();
            const locationSelect = document.getElementById('final-location-select');
            locationSelect.innerHTML = allLocations.map(loc => `<option value="${loc}" ${card.Location === loc ? 'selected' : ''}>${loc}</option>`).join('')
                + '<option value="__addNew__">Add New Location...</option>';
            
            progressDiv.classList.add('hidden');
            resultsDiv.classList.remove('hidden');

            document.getElementById('manual-recomp-btn').addEventListener('click', () => {
                const instructions = document.getElementById('manual-recomp-instructions').value;
                if (!instructions.trim()) {
                    showToast("Please provide some instructions to re-comp.", 'error');
                    return;
                }
                executeRunComps(card, instructions); 
            });

            document.getElementById('comps-accept-btn').onclick = async () => {
                const finalSticker = parseFloat(document.getElementById('final-sticker-price').value);
                const finalLocation = document.getElementById('final-location-select').value;
                const originalSticker = card['Current Sticker'] || null;
                const compNotesForSave = `Links:\n${(research.source_urls || []).join('\n')}\n\nJustification:\n[${category}, ${confidence}% confidence] ${research.reasoning}\n\nCategory Insight: ${research.category_insight || 'N/A'}`;

                const fieldsToUpdate = {
                    'Current Sticker': finalSticker,
                    'Location': finalLocation,
                    'Comp Notes': compNotesForSave,
                };
                if (originalSticker) {
                    fieldsToUpdate['Original Sticker'] = originalSticker;
                }

                try {
                    const acceptBtn = document.getElementById('comps-accept-btn');
                    acceptBtn.disabled = true;
                    acceptBtn.textContent = 'Saving...';
                    await airtableFetch('PATCH', `/${card.id}`, { fields: fieldsToUpdate, typecast: true });
                    
                    const recordIndex = state.records.findIndex(r => r.id === card.id);
                    if (recordIndex !== -1) { state.records[recordIndex] = { ...state.records[recordIndex], ...fieldsToUpdate }; }
                    if (state.selectedCard?.id === card.id) { state.selectedCard = { ...state.selectedCard, ...fieldsToUpdate }; }
                    await cacheSet(CACHE_KEYS.full, state.records);
                    const summary = state.records.map(r => ({id: r.id, CardID: r.CardID, Player: r.Player, Set: r.Set, 'Current Sticker': r['Current Sticker'], Location: r.Location, FrontPhoto: r.FrontPhoto, BackPhoto: r.BackPhoto }));
                    await cacheSet(CACHE_KEYS.summary, summary);
                    
                    document.getElementById('run-comps-modal').classList.remove('show');
                    showToast('Card updated successfully!');
                    
                    if (state.currentView === 'card-detail') {
                        initCardDetail(card.id);
                    }
                } catch (error) {
                    showToast(`Failed to save: ${error.message}`, 'error');
                }
            };
        }
        
        function displayNoCompsFound(card) {
            const resultsDiv = document.getElementById('comps-results');
            const progressDiv = document.getElementById('comps-progress');
            document.getElementById('comps-modal-title').textContent = 'Comps Analysis Complete';

            resultsDiv.innerHTML = `
                <div class="text-center p-8 bg-yellow-50 dark:bg-yellow-900/50 rounded-lg border-2 border-dashed border-yellow-400 dark:border-yellow-700">
                    <p class="text-2xl font-bold text-yellow-700 dark:text-yellow-300">⚠️</p>
                    <h4 class="text-xl font-bold mt-2">No Comps Found</h4>
                    <p class="mt-2 text-gray-600 dark:text-gray-400">The card cannot be comped automatically. Manual research is required.</p>
                </div>

                <div class="mt-6 border-t dark:border-gray-700 pt-4">
                    <h4 class="font-bold text-lg">Manual Re-Comp</h4>
                    <p class="text-sm text-gray-500 dark:text-gray-400 mb-2">
                        Provide additional instructions, suggest comparables, or add your own research links to try again.
                    </p>
                    <textarea id="manual-recomp-instructions" class="w-full rounded-md p-2 border-gray-300 dark:border-gray-600" placeholder="e.g., 'This is a rare refractor, try searching for 2023 Topps Chrome Haaland refractors instead of the base card.' or 'Try this comp: https://www.ebay.com/itm/...'"></textarea>
                    <div class="flex justify-end mt-2">
                        <button id="manual-recomp-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded">Re-Comp with Instructions</button>
                    </div>
                </div>

                 <div class="mt-6 border-t dark:border-gray-700 pt-4">
                    <h4 class="font-bold text-lg">Set Manual Price</h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2 items-end">
                        <div>
                            <label for="final-sticker-price" class="block text-sm font-medium">Final Sticker Price (THB)</label>
                            <input id="final-sticker-price" type="number" step="10" class="mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600" value="0">
                        </div>
                        <div>
                            <label for="final-location-select" class="block text-sm font-medium">Set Location</label>
                            <select id="final-location-select" class="mt-1 block w-full rounded-md p-2 border-gray-300 dark:border-gray-600">
                            </select>
                        </div>
                    </div>
                    <div class="flex justify-end mt-4">
                         <button id="comps-accept-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded">Save</button>
                    </div>
                </div>
            `;
             progressDiv.classList.add('hidden');
             resultsDiv.classList.remove('hidden');

             const allLocations = [...new Set([...LOCATIONS, ...state.records.map(r => r.Location).filter(Boolean)])].sort();
             const locationSelect = document.getElementById('final-location-select');
             locationSelect.innerHTML = allLocations.map(loc => `<option value="${loc}" ${card.Location === loc ? 'selected' : ''}>${loc}</option>`).join('');

            document.getElementById('manual-recomp-btn').addEventListener('click', () => {
                const instructions = document.getElementById('manual-recomp-instructions').value;
                if (!instructions.trim()) {
                    showToast("Please provide some instructions to re-comp.", 'error');
                    return;
                }
                executeRunComps(card, instructions); 
            });

             document.getElementById('comps-accept-btn').onclick = async () => {
                const finalSticker = parseFloat(document.getElementById('final-sticker-price').value);
                const finalLocation = document.getElementById('final-location-select').value;
                const fieldsToUpdate = {
                    'Current Sticker': finalSticker,
                    'Location': finalLocation,
                    'Comp Notes': 'Manual price set - no automatic comps found.',
                };

                 try {
                     await airtableFetch('PATCH', `/${card.id}`, { fields: fieldsToUpdate, typecast: true });
                     showToast('Card updated manually!');
                     document.getElementById('run-comps-modal').classList.remove('show');
                     if (state.currentView === 'card-detail') { initCardDetail(card.id); }
                 } catch (error) {
                    showToast(`Failed to save: ${error.message}`, 'error');
                 }
             }
        }

        function displayCompsError(errorMessage) {
            const resultsDiv = document.getElementById('comps-results');
            const progressDiv = document.getElementById('comps-progress');
            document.getElementById('comps-modal-title').textContent = 'An Error Occurred';

            resultsDiv.innerHTML = `
                 <div class="text-center p-8 bg-red-50 dark:bg-red-900/50 rounded-lg border-2 border-dashed border-red-400 dark:border-red-700">
                    <p class="text-2xl font-bold text-red-700 dark:text-red-300">!</p>
                    <h4 class="text-xl font-bold mt-2">Pricing Failed</h4>
                    <p class="mt-2 text-gray-600 dark:text-gray-400">An error occurred while trying to price the card.</p>
                    <div class="mt-4 text-sm text-left bg-gray-100 dark:bg-gray-800 p-2 rounded overflow-x-auto">
                        <code>${errorMessage}</code>
                    </div>
                </div>
            `;
            progressDiv.classList.add('hidden');
            resultsDiv.classList.remove('hidden');
        }

        /**
         * Self-test function to verify the pricing module's functionality.
         */
        async function RUN_SELFTEST() {
            console.log("✅ SELF-TEST REQUIREMENT: STARTING SELF-TEST ✅");
            const testCases = [
                { name: "Sports (graded)", data: { Player: "Erling Haaland", Year: "2023", Set: "Topps Chrome", "Card#": "1", "Grading Company": "PSA", Grade: "9" } },
                { name: "Sports (raw)", data: { Player: "Bukayo Saka", Year: "2021", Set: "Panini Prizm", "Card#": "1" } },
                { name: "Anime / Pokémon", data: { Player: "Charizard VMAX", Year: "2022", Set: "Pokémon Sword & Shield", "Grading Company": "PSA", Grade: "10" } },
                { name: "No comps", data: { Player: "Jim Boeheim", Year: "2025", Set: "Leaf Metal Autographs", 'Limited#': '1/1', "Grading Company": "PSA" } },
                { name: "Missing data", data: { Player: "Incomplete Entry" } },
                { name: "Pokémon Japanese SR", data: { Player: "ピカチュウ", Year: "2021", Set: "Pokémon VMAX Climax", Parallel: "SR"}},
                { name: "Weiss Schwarz Foil", data: { Player: "Asuna", Year: "2020", Set: "Weiss Schwarz Sword Art Online", Parallel: "Foil"}},
                { name: "Low-pop PSA 10", data: { Player: "LeBron James", Year: "2003", Set: "Topps Chrome", "Card#": "111", "Grading Company": "PSA", Grade: "10"}},
                { name: "Raw numbered soccer", data: { Player: "Lionel Messi", Year: "2022", Set: "Panini Prizm World Cup", 'Limited#': '/25'}}
            ];

            for (const test of testCases) {
                console.log(`--- Running Test Case: ${test.name} ---`);
                try {
                    console.log("[TEST] Simulating 'Run Comps' click...");
                    const modal = document.getElementById('run-comps-modal');
                    modal.classList.add('show');
                    document.getElementById('comps-progress').classList.remove('hidden');
                    document.getElementById('comps-results').classList.add('hidden');
                    console.log("[TEST] Loading UI... OK");

                    const result = await getGeminiComps(test.data);

                    if (!result || !result.status) {
                        throw new Error("Result object is invalid or missing status.");
                    }
                    
                    if (test.name === "No comps") {
                        if (result.status === "NO_DATA") {
                            console.log("[TEST] No-data case returned 'NO_DATA' status... OK");
                        } else {
                             console.warn(`Expected 'NO_DATA' status but got '${result.status}'. This might be ok if a speculative price was found.`);
                        }
                    } else if (test.name === "Missing data") {
                         if (result.status) {
                            console.log(`[TEST] Missing data case returned a valid status ('${result.status}')... OK`);
                         } else {
                            throw new Error("Missing data case failed to return a valid status.");
                         }
                    }
                    else {
                        if (result.status === "SUCCESS") {
                            console.log("[TEST] Returned 'SUCCESS' status... OK");
                            if (typeof result.pricing.fmv_usd === 'number') {
                                console.log(`[TEST] FMV is a number (${result.pricing.fmv_usd})... OK`);
                            } else {
                                throw new Error(`FMV is not a number: ${result.pricing.fmv_usd}`);
                            }
                            if (Array.isArray(result.research.source_urls) && result.research.source_urls.length > 0) {
                                console.log(`[TEST] Found ${result.research.source_urls.length} research links... OK`);
                            } else {
                                console.warn("[TEST] No research URLs returned, but might be acceptable.");
                            }
                            if (typeof result.research.reasoning === 'string' && result.research.reasoning.length > 5) {
                                console.log("[TEST] Reasoning text is present... OK");
                            } else {
                                 throw new Error("Reasoning text is missing or too short.");
                            }
                        } else {
                            throw new Error(`Expected 'SUCCESS' status but got '${result.status}'. Reason: ${result.research?.reasoning}`);
                        }
                    }
                    console.log(`--- Test Case '${test.name}' PASSED ---`);
                } catch (error) {
                    console.error(`--- ❌ Test Case '${test.name}' FAILED ❌ ---`);
                    console.error("Error:", error.message);
                } finally {
                    document.getElementById('run-comps-modal').classList.remove('show');
                }
            }
             console.log("✅ SELF-TEST REQUIREMENT: SELF-TEST COMPLETE ✅");
        }
        window.RUN_SELFTEST = RUN_SELFTEST;
        
        // --- PRICING MODULE END ---

        async function getGeminiVisionData(frontData, backData) {
            const { geminiApiKey } = getCredentials();
            if (!geminiApiKey) {
                throw new Error("A Gemini API Key is required to scan cards.");
            }
            const model = 'gemini-2.5-flash-preview-05-20';
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${geminiApiKey}`;

            const prompt = `Analyze these sports card images. First, determine if it's a graded card in a slab (like PSA, SQC, BGS).
If it IS GRADED, you MUST extract: "Grading Company", the numeric "Grade", and the "Cert/Serial" number. For PSA, this is 7-10 digits on the FRONT. For SQC, this is a number starting with "SN" on the BACK.
If it is NOT GRADED (a raw card), return null for those three fields.
Always extract the standard card details: "Player", "Set" (do not include the year in the set name), "Year" (as a four-digit string), "Card#", "Subset", "Parallel", and "Limited#".
Return ONLY a single, clean JSON object with this exact structure, with null for any value you cannot find:
{"Player": "string", "Set": "string", "Year": "string", "Card#": "string", "Subset": "string", "Parallel": "string", "Limited#": "string", "Grading Company": "string" or null, "Grade": "string" or null, "Cert/Serial": "string" or null}`;
            
            const parts = [{ text: prompt }];
            if(frontData) {
                parts.push({ inline_data: { mime_type: frontData.mimeType, data: frontData.base64 } });
            }
             if(backData) {
                parts.push({ inline_data: { mime_type: backData.mimeType, data: backData.base64 } });
            }
            
            const payload = { contents: [{ parts }] };

            const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`Gemini Vision API error: ${response.statusText}`);
            const data = await response.json();
            
            if (!data.candidates || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0].text) {
                throw new Error("Invalid response structure from Gemini Vision API.");
            }

            const textResponse = data.candidates[0].content.parts[0].text;
            const jsonMatch = textResponse.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                throw new Error("Could not find a valid JSON object in the Gemini Vision response.");
            }
            return JSON.parse(jsonMatch[0]);
        }
        
        async function savePhoto(recordId, field, url) {
             try {
                const fields = { [field]: [{ url }] };
                await airtableFetch('PATCH', `/${recordId}`, { fields, typecast: true });
                
                const recordIndex = state.records.findIndex(r => r.id === recordId);
                if (recordIndex !== -1) state.records[recordIndex][field] = [{ url }];
                if (state.selectedCard?.id === recordId) state.selectedCard[field] = [{ url }];
                await cacheSet(CACHE_KEYS.full, state.records);
                const summary = state.records.map(r => ({id: r.id, CardID: r.CardID, Player: r.Player, Set: r.Set, 'Current Sticker': r['Current Sticker'], Location: r.Location, FrontPhoto: r.FrontPhoto, BackPhoto: r.BackPhoto }));
                await cacheSet(CACHE_KEYS.summary, summary);

                showToast('Photo added successfully!');
                initCardDetail(recordId); // Re-render the view
            } catch (error) {
                showToast('Failed to save photo.', 'error');
            }
        }

        // --- APP ROUTER & INITIALIZATION ---
        function navigate(view, params = {}) {
            state.currentView = view;
            const contentArea = document.getElementById('content-area');
            if (!contentArea) return; 
            
            if(params.from) {
                state.fromView = params.from;
            } else if (view !== 'card-detail' && view !== 'edit-card'){
                state.fromView = null;
            }


            document.querySelectorAll('.nav-link').forEach(link => link.classList.toggle('active', link.dataset.view === view.split('-')[0]));
            
            switch (view) {
                case 'dashboard': initDashboard(); break;
                case 'intake': 
                    initIntake(params);
                    break;
                case 'audit': initAudit(params.location, params.page); break;
                case 'audit-photo':
                    state.photoAuditType = params.photoType; // Store it
                    renderAuditPhotoDetail(params.location, params.photoType);
                    break;
                case 'card-detail': initCardDetail(params.recordId); break;
                case 'edit-card': renderIntakeForm(params.record, false); break;
                case 'search': initSearch(params.query, params.page); break;
                default: initDashboard();
            }
        }

        function renderAppShell() {
            appContainer.innerHTML = `
                <header class="bg-white dark:bg-gray-800 shadow-md rounded-lg p-4 mb-6">
                    <div class="flex flex-col md:flex-row items-center justify-between">
                        <div class="flex items-center space-x-4">
                            <img src="https://i.ibb.co/ShzzdKT/logo-header-h64.png" alt="Cooks Collectibles Logo" class="h-12 md:h-16 w-auto">
                        </div>
                        <div class="flex items-center space-x-4">
                            <nav id="navigation" class="flex space-x-2 mt-4 md:mt-0">
                                <button data-view="dashboard" class="nav-link px-4 py-2 rounded-md text-sm font-medium text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700">Dashboard</button>
                                <button data-view="intake" class="nav-link px-4 py-2 rounded-md text-sm font-medium text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700">Intake</button>
                                <button data-view="audit" class="nav-link px-4 py-2 rounded-md text-sm font-medium text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700">Audit</button>
                                <button data-view="search" class="nav-link px-4 py-2 rounded-md text-sm font-medium text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700">Search</button>
                            </nav>
                            <button id="theme-toggle" class="mt-4 md:mt-0 p-2 rounded-md text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700">
                                <svg id="theme-icon-light" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>
                                <svg id="theme-icon-dark" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg>
                            </button>
                        </div>
                    </div>
                </header>
                <div id="config-container" class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 rounded-md mb-6" role="alert">
                    <p class="font-bold">Configuration</p>
                    <p>Enter your API credentials below. These are stored only in your browser.</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 mt-2 items-end">
                        <div><label for="apiKey" class="block text-sm font-medium">Airtable API Key</label><input type="password" id="apiKey" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2" value="patoHcB5BiGzANgna.d321310ecb88397b355eb522eec25c5fe713cff791f6e431ce17bb703ff3ee77"></div>
                        <div><label for="baseId" class="block text-sm font-medium">Airtable Base ID</label><input type="text" id="baseId" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2" value="app7DQrgI2EZ3ogzq"></div>
                        <div><label for="tableName" class="block text-sm font-medium">Airtable Table Name</label><input type="text" id="tableName" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2" value="Inventory"></div>
                        <div><label for="geminiApiKey" class="block text-sm font-medium">Gemini API Key</label><input type="password" id="geminiApiKey" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2"></div>
                        <div><label for="imgbbApiKey" class="block text-sm font-medium">ImgBB API Key</label><input type="password" id="imgbbApiKey" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2"></div>
                    </div>
                </div>
                <main id="content-area"></main>
            `;
        }


        function initApp() {
            renderAppShell();
            
            document.getElementById('theme-toggle').addEventListener('click', () => {
              const root = document.documentElement;
              const isDark = root.classList.toggle('dark');
              localStorage.setItem('theme', isDark ? 'dark' : 'light');
              document.getElementById('theme-icon-light').classList.toggle('hidden', isDark);
              document.getElementById('theme-icon-dark').classList.toggle('hidden', !isDark);
            });
            
            (function(){
              const isDark = document.documentElement.classList.contains('dark');
              document.getElementById('theme-icon-light').classList.toggle('hidden', isDark);
              document.getElementById('theme-icon-dark').classList.toggle('hidden', !isDark);
            })();

            document.addEventListener('click', (e) => {
                const navLink = e.target.closest('.nav-link');
                if (navLink) return navigate(navLink.dataset.view);

                const cardLink = e.target.closest('.view-card-link');
                if (cardLink) {
                    e.preventDefault();
                    const recordId = cardLink.dataset.recordId;
                    if (recordId) {
                        let from = { view: state.currentView, params: {} };
                        if (state.currentView === 'audit' && state.auditSelectedLocation) {
                            from.params = { location: state.auditSelectedLocation, page: state.auditCurrentPage };
                        } else if (state.currentView === 'audit') {
                            from.params = {};
                        } else if (state.currentView === 'search') {
                            from.params = { query: state.searchQuery, page: state.searchCurrentPage };
                        } else if (state.currentView === 'audit-photo') {
                             from.params = { location: state.auditSelectedLocation, photoType: state.photoAuditType, page: state.auditCurrentPage };
                        }
                        
                        navigate('card-detail', { recordId, from });
                    }
                    return;
                }
                
                const backLink = e.target.closest('#back-link');
                if(backLink) {
                    e.preventDefault();
                    if (state.fromView && (state.fromView.view === 'audit' || state.fromView.view === 'search' || state.fromView.view === 'audit-photo')) {
                         navigate(state.fromView.view, state.fromView.params);
                    } else {
                        navigate('dashboard');
                    }
                    return;
                }

                const addPhotoButton = e.target.closest('[data-action="add-photo-start"]');
                if (addPhotoButton) {
                    const { imgbbApiKey } = getCredentials();
                    if (!imgbbApiKey) {
                        showToast('Please enter an ImgBB API Key.', 'error');
                        return;
                    }
                    state.photoUploadTarget = addPhotoButton.dataset.field;
                    document.getElementById('photo-upload-input').click();
                    return;
                }
                
                const togglePhotoButton = e.target.closest('[data-action="toggle-photo"]');
                if(togglePhotoButton) {
                    const cardImage = document.getElementById('card-image-display');
                    const currentSrc = cardImage.src;
                    const card = state.selectedCard;
                    
                    if (card.FrontPhoto?.[0]?.url && currentSrc.includes(card.FrontPhoto[0].url)) {
                        cardImage.src = card.BackPhoto?.[0]?.url || 'https://placehold.co/400x560/eee/ccc?text=No+Back+Image';
                        togglePhotoButton.textContent = 'Show Front';
                    } else {
                        cardImage.src = card.FrontPhoto?.[0]?.url || 'https://placehold.co/400x560/eee/ccc?text=No+Front+Image';
                        togglePhotoButton.textContent = 'Show Back';
                    }
                    return;
                }

                const actionButton = e.target.closest('#card-actions button, [data-action^="edit-location"], [data-action^="navigate"]');
                if (actionButton) {
                    const { action, recordId } = actionButton.dataset;
                    const card = state.selectedCard;
                    if (!card && !recordId) return;

                    switch (action) {
                        case 'edit': return navigate('edit-card', { record: card });
                        case 'add-another': return navigate('intake', { record: { ...card }, isDuplicate: true });
                        case 'run-comps': return executeRunComps(card);
                        case 'delete':
                            return showConfirmationModal({
                                title: 'Delete Card?',
                                body: `Permanently delete Card ID ${card.CardID} (${card.Player})? This cannot be undone.`,
                                onConfirm: async () => {
                                    await airtableFetch('DELETE', `/${card.id}`);
                                    state.records = state.records.filter(r => r.id !== card.id);
                                    await cacheSet(CACHE_KEYS.full, state.records);
                                    const summary = state.records.map(r => ({id: r.id, CardID: r.CardID, Player: r.Player, Set: r.Set, 'Current Sticker': r['Current Sticker'], Location: r.Location }));
                                    await cacheSet(CACHE_KEYS.summary, summary);
                                    hideConfirmationModal();
                                    showToast('Card deleted.');
                                    navigate('audit');
                                }
                            });
                        case 'edit-location-start': {
                            document.getElementById('location-display-view').classList.add('hidden');
                            const editView = document.getElementById('location-edit-view');
                            editView.classList.remove('hidden');
                            const select = document.getElementById('card-detail-location-select');
                            const allLocations = [...new Set([...LOCATIONS, ...state.records.map(r => r.Location).filter(Boolean)])].sort();
                            select.innerHTML = allLocations.map(loc => `<option value="${loc}" ${card.Location === loc ? 'selected' : ''}>${loc}</option>`).join('') + '<option value="__addNew__">Add New Location...</option>';
                            select.onchange = () => {
                                document.getElementById('card-detail-location-manual').classList.toggle('hidden', select.value !== '__addNew__');
                            };
                            return;
                        }
                        case 'edit-location-cancel': {
                            document.getElementById('location-display-view').classList.remove('hidden');
                            document.getElementById('location-edit-view').classList.add('hidden');
                            return;
                        }
                        case 'edit-location-save': {
                            const select = document.getElementById('card-detail-location-select');
                            const newLocation = select.value === '__addNew__'
                                ? document.getElementById('card-detail-location-manual').value.trim()
                                : select.value;
                            updateCardLocation(card.id, newLocation);
                            return;
                        }
                        case 'navigate-prev':
                        case 'navigate-next': {
                            if (recordId) {
                                navigate('card-detail', { recordId, from: state.fromView });
                            }
                            return;
                        }
                    }
                }
                
                const locationLink = e.target.closest('.audit-location-link');
                if(locationLink){
                    e.preventDefault();
                    return navigate('audit', { location: locationLink.dataset.location, page: 1 });
                }
                
                const photoAuditLink = e.target.closest('.photo-audit-link');
                if (photoAuditLink) {
                    e.preventDefault();
                    const location = photoAuditLink.dataset.location;
                    const photoType = photoAuditLink.dataset.photoType;
                    return navigate('audit-photo', { location, photoType, page: 1 });
                }

                const pageNavBtn = e.target.closest('.search-pagination-btn, .pagination-btn');
                if(pageNavBtn){
                    const isPhotoAudit = pageNavBtn.classList.contains('photo-audit-pagination');
                    const direction = pageNavBtn.dataset.pageNav;
                    
                    if (isPhotoAudit) {
                        const newPage = direction === 'next' ? state.auditCurrentPage + 1 : state.auditCurrentPage - 1;
                        navigate('audit-photo', { location: state.auditSelectedLocation, photoType: state.photoAuditType, page: newPage });
                    } else if (pageNavBtn.classList.contains('search-pagination-btn')) {
                         const newPage = direction === 'next' ? state.searchCurrentPage + 1 : state.searchCurrentPage - 1;
                         renderSearchResults(newPage);
                    } else {
                         const newPage = direction === 'next' ? state.auditCurrentPage + 1 : state.auditCurrentPage - 1;
                        return navigate('audit', { location: state.auditSelectedLocation, page: newPage });
                    }
                }
                
                const compsCancelBtn = e.target.closest('#comps-cancel-btn');
                if(compsCancelBtn || e.target === document.getElementById('run-comps-modal')) {
                    document.getElementById('run-comps-modal').classList.remove('show');
                }

                if (e.target.id === 'modal-confirm-btn' && state._modalConfirmCallback) state._modalConfirmCallback();
                if (e.target.id === 'modal-cancel-btn' || e.target === document.getElementById('confirmation-modal')) hideConfirmationModal();
            });
            
            async function handlePhotoUpload(e) {
                const file = e.target.files?.[0];
                if (!file) return;

                const { imgbbApiKey } = getCredentials();
                if (!imgbbApiKey) {
                    showToast('Please enter an ImgBB API Key.', 'error');
                    return;
                }

                const targetField = state.photoUploadTarget;
                if (!targetField) return;
                
                const originalButton = document.querySelector(`button[data-field="${targetField}"]`);
                const originalButtonText = originalButton ? originalButton.textContent : 'Upload';
                if(originalButton) originalButton.textContent = 'Uploading...';
                if(originalButton) originalButton.disabled = true;

                const formData = new FormData();
                formData.append('image', file);

                try {
                    const response = await fetch(`https://api.imgbb.com/1/upload?key=${imgbbApiKey}`, {
                        method: 'POST',
                        body: formData,
                    });
                    const result = await response.json();
                    if (!result.success) {
                        throw new Error(result.error?.message || 'Unknown upload error');
                    }
                    const imageUrl = result.data.url;

                    if (state.currentView === 'card-detail') {
                        await savePhoto(state.selectedCard.id, targetField, imageUrl);
                    } else {
                        const inputField = document.querySelector(`input[name="${targetField}"]`);
                        if (inputField) {
                            inputField.value = imageUrl;
                            showToast('Photo uploaded!', 'success');
                        }
                    }
                } catch (error) {
                    showToast(`Upload failed: ${error.message}`, 'error');
                    console.error("ImgBB Upload Error:", error);
                } finally {
                    if (originalButton) {
                        originalButton.textContent = originalButtonText;
                        originalButton.disabled = false;
                    }
                    e.target.value = ''; // Reset file input
                }
            }

            document.getElementById('photo-upload-input').addEventListener('change', handlePhotoUpload);
            // Initial load
            navigate('dashboard');
        }

        // --- START THE APP ---
        document.addEventListener('DOMContentLoaded', initApp);

    </script>
</body>
</html>



